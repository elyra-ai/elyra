{"version":3,"file":"vendors-node_modules_rjsf_utils_lib_index_js.9f7fafa46c4a9dfe53e3.js","mappings":"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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;AACvB,eAAe;AACf,kBAAkB;AAClB,gBAAgB;AAChB,YAAY;AACZ,YAAY;AACZ,cAAc;AACd,gBAAgB;AAChB,kBAAkB;AAClB,gBAAgB;AAChB,oBAAoB;AACpB,mBAAmB;AACnB,wBAAwB;AACxB,yBAAyB;AACzB,yBAAyB;AACzB,iBAAiB;AACjB,oBAAoB;AACpB,kBAAkB;AAClB,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,kBAAkB;AAClB,oBAAoB;AACpB,kBAAkB;AAClB,sBAAsB;AACtB,0BAA0B;AAC1B,cAAc;AACd,GAAG;AACH;;;;;;;;;;;;AC5Na;;AAEb,IAAI,KAAqC,EAAE,EAE1C,CAAC;AACF,EAAE,6JAAyD;AAC3D;;;;;;;;;;;;ACNa;;AAEb;;AAEA,cAAc,mBAAO,EAAE,4EAAmB;AAC1C,kBAAkB,mBAAO,EAAE,4FAA2B;AACtD,cAAc,mBAAO,EAAE,kFAAsB;;;AAG7C;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;;;;;ACnNa;;AAEb;;AAEA,UAAU,mBAAO,EAAE,gEAAa;AAChC,WAAW,mBAAO,EAAE,4EAAmB;AACvC,kBAAkB,mBAAO,EAAE,4FAA2B;AACtD,cAAc,mBAAO,EAAE,kFAAsB;;;AAG7C;;AAEA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;;;;AC9GA,cAAc,mBAAO,CAAC,4DAAgB;AACtC,aAAa,mBAAO,CAAC,0DAAe;AACpC,WAAW,mBAAO,CAAC,sDAAa;AAChC,eAAe,mBAAO,CAAC,8DAAiB;AACxC,eAAe,mBAAO,CAAC,8DAAiB;AACxC,uBAAuB,mBAAO,CAAC,8EAAyB;AACxD,oBAAoB,mBAAO,CAAC,wEAAsB;AAClD,gBAAgB,mBAAO,CAAC,gEAAkB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,iEAAiE;AACjE;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;ACvLA,gBAAgB,mBAAO,CAAC,4DAAgB;AACxC,oBAAoB,mBAAO,CAAC,oEAAoB;AAChD,sBAAsB,mBAAO,CAAC,wEAAsB;AACpD,aAAa,mBAAO,CAAC,sDAAa;AAClC,iBAAiB,mBAAO,CAAC,8DAAiB;AAC1C,gBAAgB,mBAAO,CAAC,4DAAgB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CA,gBAAgB,mBAAO,CAAC,gFAAqB;AAC7C,gBAAgB,mBAAO,CAAC,4DAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,2EAAW;;AAEvB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AChGA,gBAAgB,mBAAO,CAAC,gFAAqB;AAC7C,gBAAgB,mBAAO,CAAC,4DAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,2EAAW;;AAEvB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC/EA,kBAAkB,mBAAO,CAAC,gEAAkB;AAC5C,gBAAgB,mBAAO,CAAC,gFAAqB;AAC7C,mBAAmB,mBAAO,CAAC,gEAAa;AACxC,qBAAqB,mBAAO,CAAC,sEAAqB;AAClD,gBAAgB,mBAAO,CAAC,4DAAgB;AACxC,oBAAoB,mBAAO,CAAC,oEAAoB;AAChD,qBAAqB,mBAAO,CAAC,sEAAqB;AAClD,yBAAyB,mBAAO,CAAC,8EAAyB;AAC1D,gBAAgB,mBAAO,CAAC,4DAAgB;AACxC,sBAAsB,mBAAO,CAAC,wEAAsB;AACpD,gBAAgB,mBAAO,CAAC,4DAAgB;AACxC,eAAe,mBAAO,CAAC,0DAAe;AACtC,aAAa,mBAAO,CAAC,sDAAa;AAClC,iBAAiB,mBAAO,CAAC,8DAAiB;;AAE1C,2BAA2B,mBAAO,CAAC,sHAAgC;AACnE,sBAAsB,mBAAO,CAAC,4GAA2B;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI,UAAU;AACnB;AACA;;AAEA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;AACA,KAAK,KAAK;;AAEV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK,IAAI;AACT,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,aAAa;AACb,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACtVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX,WAAW;AACX,eAAe;;;;;;;;;;;ACnGf,eAAe,mBAAO,CAAC,2DAAa;AACpC,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC1BA,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,SAAS,mBAAO,CAAC,6CAAM;;AAEvB;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA,eAAe,mBAAO,CAAC,2DAAa;AACpC,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,wBAAwB,mBAAO,CAAC,6EAAsB;AACtD,eAAe,mBAAO,CAAC,2DAAa;AACpC,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvBA,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,oBAAoB,mBAAO,CAAC,qEAAkB;;AAE9C;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA,eAAe,mBAAO,CAAC,2DAAa;AACpC,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,wBAAwB,mBAAO,CAAC,6EAAsB;AACtD,eAAe,mBAAO,CAAC,2DAAa;AACpC,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzEA,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3BA,YAAY,mBAAO,CAAC,qDAAU;AAC9B,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,aAAa,mBAAO,CAAC,uDAAW;AAChC,cAAc,mBAAO,CAAC,uDAAW;AACjC,eAAe,mBAAO,CAAC,yDAAY;AACnC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClFA,YAAY,mBAAO,CAAC,qDAAU;AAC9B,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACXA,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,0BAA0B,mBAAO,CAAC,iFAAwB;AAC1D,eAAe,mBAAO,CAAC,yDAAY;AACnC,cAAc,mBAAO,CAAC,uD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,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;ACtBA,eAAe,mBAAO,CAAC,yDAAY;AACnC,eAAe,mBAAO,CAAC,2DAAa;AACpC,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpBA,sBAAsB,mBAAO,CAAC,yEAAoB;;AAElD;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClBA,eAAe,mBAAO,CAAC,2DAAa;AACpC,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,wBAAwB,mBAAO,CAAC,6EAAsB;AACtD,eAAe,mBAAO,CAAC,2DAAa;AACpC,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACZA,wBAAwB,mBAAO,CAAC,2EAAqB;;AAErD;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACbA,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxCA,uBAAuB,mBAAO,CAAC,2EAAqB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3CA,eAAe,mBAAO,CAAC,2DAAa;AACpC,qBAAqB,mBAAO,CAAC,uEAAmB;;AAEhD;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;ACpCA,UAAU,mBAAO,CAAC,iDAAQ;AAC1B,WAAW,mBAAO,CAAC,iDAAQ;AAC3B,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClBA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3BA,eAAe,mBAAO,CAAC,2DAAa;AACpC,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnFA,aAAa,mBAAO,CAAC,uDAAW;AAChC,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,SAAS,mBAAO,CAAC,6CAAM;AACvB,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/GA,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzFA,yBAAyB,mBAAO,CAAC,+EAAuB;AACxD,WAAW,mBAAO,CAAC,iDAAQ;;AAE3B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvBA,SAAS,mBAAO,CAAC,6CAAM;AACvB,kBAAkB,mBAAO,CAAC,+DAAe;AACzC,cAAc,mBAAO,CAAC,yDAAY;AAClC,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7BA,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACpBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AClBA,eAAe,mBAAO,CAAC,2DAAa;AACpC,SAAS,mBAAO,CAAC,6CAAM;AACvB,qBAAqB,mBAAO,CAAC,uEAAmB;AAChD,aAAa,mBAAO,CAAC,qDAAU;;AAE/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,gBAAgB,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AAChD,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;AC/DA,YAAY,mBAAO,CAAC,qDAAU;AAC9B,eAAe,mBAAO,CAAC,2DAAa;AACpC,0BAA0B,mBAAO,CAAC,iFAAwB;AAC1D,gBAAgB,mBAAO,CAAC,2DAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,oBAAoB,OAAO,UAAU,IAAI,OAAO,kBAAkB;AAClE,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;AC7BA,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA,eAAe,mBAAO,CAAC,2DAAa;AACpC,uBAAuB,mBAAO,CAAC,2EAAqB;AACpD,eAAe,mBAAO,CAAC,2DAAa;AACpC,0BAA0B,mBAAO,CAAC,iFAAwB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;AC7BA,eAAe,mBAAO,CAAC,2DAAa;AACpC,uBAAuB,mBAAO,CAAC,2EAAqB;AACpD,eAAe,mBAAO,CAAC,2DAAa;AACpC,0BAA0B,mBAAO,CAAC,iFAAwB;AAC1D,WAAW,mBAAO,CAAC,iDAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA,oBAAoB,gBAAgB,IAAI,gBAAgB;AACxD,mBAAmB,gBAAgB,IAAI,gBAAgB;AACvD;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;ACxCA,kBAAkB,mBAAO,CAAC,+DAAe;AACzC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChCA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5BA,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClCA,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrCA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,cAAc,mBAAO,CAAC,uDAAW;AACjC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7BA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,qBAAqB,mBAAO,CAAC,uEAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,QAAQ,IAAI,QAAQ;AACjC;AACA;AACA;AACA,aAAa,QAAQ,IAAI,QAAQ;AACjC;AACA;AACA;AACA,WAAW,QAAQ,gBAAgB,IAAI,gBAAgB;AACvD;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;ACtCA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,qBAAqB,mBAAO,CAAC,uEAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,uBAAuB,mBAAO,CAAC,2EAAqB;AACpD,YAAY,mBAAO,CAAC,qDAAU;AAC9B,YAAY,mBAAO,CAAC,qDAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa,UAAU;AACvB;AACA;AACA;AACA,OAAO,OAAO,UAAU;AACxB,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/BA,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5BA,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,eAAe,mBAAO,CAAC,2DAAa;AACpC,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,cAAc,mBAAO,CAAC,uDAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA,IAAI,IAAI;AACR,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AClDA,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,eAAe,mBAAO,CAAC,2DAAa;AACpC,qBAAqB,mBAAO,CAAC,uEAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,0BAA0B;AACrC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,OAAO,6BAA6B;AACpC,OAAO,6BAA6B;AACpC,OAAO,6BAA6B;AACpC,OAAO;AACP;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;AC/CA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,gBAAgB,mBAAO,CAAC,2DAAa;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClDA,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzCA,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACnCA,eAAe,mBAAO,CAAC,2DAAa;AACpC,eAAe,mBAAO,CAAC,yDAAY;AACnC,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/DA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,aAAa,mBAAO,CAAC,qDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,WAAW;AACX;AACA,cAAc,QAAQ;AACtB,WAAW;AACX;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/BA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,cAAc,mBAAO,CAAC,uDAAW;AACjC,eAAe,mBAAO,CAAC,yDAAY;AACnC,iBAAiB,mBAAO,CAAC,6DAAc;AACvC,eAAe,mBAAO,CAAC,yDAAY;AACnC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA,IAAI,IAAI;AACR,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;AChEA,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,eAAe,mBAAO,CAAC,2DAAa;AACpC,eAAe,mBAAO,CAAC,2DAAa;AACpC,wBAAwB,mBAAO,CAAC,2EAAqB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;ACzBA,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA,oBAAoB,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB;AAC5E;AACA;AACA,YAAY,gBAAgB,IAAI,gBAAgB;AAChD;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3BA,qBAAqB,mBAAO,CAAC,uEAAmB;AAChD,eAAe,mBAAO,CAAC,2DAAa;AACpC,wBAAwB,mBAAO,CAAC,2EAAqB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;AC9Ba;;AAEb;AACA;AACA;AACA;AACA,UAAU,GAAG;AACb,YAAY,SAAS;AACrB;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA,UAAU,GAAG;AACb,YAAY,SAAS;AACrB;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,cAAc,mBAAO,EAAE,4EAAmB;AAC1C,aAAa,mBAAO,EAAE,gFAAqB;;;AAG3C;;AAEA;AACA;AACA;AACA;AACA,UAAU,GAAG;AACb,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,eAAe,mBAAO,EAAE,8EAAoB;;;AAG5C;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA,UAAU,GAAG;AACb,YAAY,SAAS;AACrB;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA","sources":["webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/ErrorSchemaBuilder.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/allowAdditionalItems.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/asNumber.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/canExpand.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/constants.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/createErrorHandler.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/createSchemaUtils.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/dataURItoBlob.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/dateRangeOptions.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/deepEquals.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/englishStringTranslator.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/enumOptionsDeselectValue.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/enumOptionsIndexForValue.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/enumOptionsIsSelected.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/enumOptionsSelectValue.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/enumOptionsValueForIndex.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/enums.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/findSchemaDefinition.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/getDateElementProps.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/getDiscriminatorFieldFromSchema.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/getInputProps.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/getOptionMatchingSimpleDiscriminator.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/getSchemaType.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/getSubmitButtonOptions.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/getTemplate.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/getUiOptions.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/getWidget.tsx","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/guessType.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/hasWidget.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/hashForSchema.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/idGenerators.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/index.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/isConstant.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/isCustomWidget.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/isFixedItems.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/isObject.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/labelValue.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/localToUTC.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/mergeDefaultsWithFormData.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/mergeObjects.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/mergeSchemas.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/optionsList.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/orderProperties.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/pad.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/parseDateString.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/parser/ParserValidator.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/parser/index.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/parser/schemaParser.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/rangeSpec.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/replaceStringParameters.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schemaRequiresTrueValue.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/getClosestMatchingOption.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/getDefaultFormState.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/getDisplayLabel.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/getFirstMatchingOption.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/getMatchingOption.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/index.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/isFilesArray.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/isMultiSelect.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/isSelect.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/mergeValidationData.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/retrieveSchema.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/sanitizeDataForNewSchema.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/toIdSchema.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/schema/toPathSchema.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/shouldRender.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/toConstant.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/toDateString.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/toErrorList.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/toErrorSchema.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/types.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/unwrapErrorHandler.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/utcToLocal.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/validationDataMerge.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/src/withIdRefPrefix.ts","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/node_modules/react-is/cjs/react-is.development.js","webpack://@elyra/ui-components/../../node_modules/@rjsf/utils/node_modules/react-is/index.js","webpack://@elyra/ui-components/../../node_modules/compute-gcd/lib/index.js","webpack://@elyra/ui-components/../../node_modules/compute-lcm/lib/index.js","webpack://@elyra/ui-components/../../node_modules/json-schema-compare/src/index.js","webpack://@elyra/ui-components/../../node_modules/json-schema-merge-allof/src/common.js","webpack://@elyra/ui-components/../../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js","webpack://@elyra/ui-components/../../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js","webpack://@elyra/ui-components/../../node_modules/json-schema-merge-allof/src/index.js","webpack://@elyra/ui-components/../../node_modules/jsonpointer/jsonpointer.js","webpack://@elyra/ui-components/../../node_modules/lodash/_SetCache.js","webpack://@elyra/ui-components/../../node_modules/lodash/_arrayIncludes.js","webpack://@elyra/ui-components/../../node_modules/lodash/_arrayIncludesWith.js","webpack://@elyra/ui-components/../../node_modules/lodash/_arrayReduce.js","webpack://@elyra/ui-components/../../node_modules/lodash/_arraySome.js","webpack://@elyra/ui-components/../../node_modules/lodash/_assignMergeValue.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseDifference.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseFindIndex.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseIndexOf.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseIndexOfWith.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseIntersection.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseIsEqual.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseIsEqualDeep.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseIsMatch.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseIsNaN.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseIteratee.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseMap.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseMatches.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseMatchesProperty.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseMerge.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseMergeDeep.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseOrderBy.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseProperty.js","webpack://@elyra/ui-components/../../node_modules/lodash/_basePropertyDeep.js","webpack://@elyra/ui-components/../../node_modules/lodash/_basePullAll.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseReduce.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseRest.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseSortBy.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseTrim.js","webpack://@elyra/ui-components/../../node_modules/lodash/_baseUniq.js","webpack://@elyra/ui-components/../../node_modules/lodash/_cacheHas.js","webpack://@elyra/ui-components/../../node_modules/lodash/_castArrayLikeObject.js","webpack://@elyra/ui-components/../../node_modules/lodash/_compareAscending.js","webpack://@elyra/ui-components/../../node_modules/lodash/_compareMultiple.js","webpack://@elyra/ui-components/../../node_modules/lodash/_createAssigner.js","webpack://@elyra/ui-components/../../node_modules/lodash/_createSet.js","webpack://@elyra/ui-components/../../node_modules/lodash/_customDefaultsMerge.js","webpack://@elyra/ui-components/../../node_modules/lodash/_equalArrays.js","webpack://@elyra/ui-components/../../node_modules/lodash/_equalByTag.js","webpack://@elyra/ui-components/../../node_modules/lodash/_equalObjects.js","webpack://@elyra/ui-components/../../node_modules/lodash/_getMatchData.js","webpack://@elyra/ui-components/../../node_modules/lodash/_isIterateeCall.js","webpack://@elyra/ui-components/../../node_modules/lodash/_isStrictComparable.js","webpack://@elyra/ui-components/../../node_modules/lodash/_mapToArray.js","webpack://@elyra/ui-components/../../node_modules/lodash/_matchesStrictComparable.js","webpack://@elyra/ui-components/../../node_modules/lodash/_safeGet.js","webpack://@elyra/ui-components/../../node_modules/lodash/_setCacheAdd.js","webpack://@elyra/ui-components/../../node_modules/lodash/_setCacheHas.js","webpack://@elyra/ui-components/../../node_modules/lodash/_setToArray.js","webpack://@elyra/ui-components/../../node_modules/lodash/_strictIndexOf.js","webpack://@elyra/ui-components/../../node_modules/lodash/_trimmedEndIndex.js","webpack://@elyra/ui-components/../../node_modules/lodash/defaults.js","webpack://@elyra/ui-components/../../node_modules/lodash/defaultsDeep.js","webpack://@elyra/ui-components/../../node_modules/lodash/flattenDeep.js","webpack://@elyra/ui-components/../../node_modules/lodash/intersection.js","webpack://@elyra/ui-components/../../node_modules/lodash/intersectionWith.js","webpack://@elyra/ui-components/../../node_modules/lodash/isArrayLikeObject.js","webpack://@elyra/ui-components/../../node_modules/lodash/isBoolean.js","webpack://@elyra/ui-components/../../node_modules/lodash/isEqual.js","webpack://@elyra/ui-components/../../node_modules/lodash/isEqualWith.js","webpack://@elyra/ui-components/../../node_modules/lodash/isNil.js","webpack://@elyra/ui-components/../../node_modules/lodash/isNumber.js","webpack://@elyra/ui-components/../../node_modules/lodash/isString.js","webpack://@elyra/ui-components/../../node_modules/lodash/merge.js","webpack://@elyra/ui-components/../../node_modules/lodash/mergeWith.js","webpack://@elyra/ui-components/../../node_modules/lodash/noop.js","webpack://@elyra/ui-components/../../node_modules/lodash/property.js","webpack://@elyra/ui-components/../../node_modules/lodash/pullAll.js","webpack://@elyra/ui-components/../../node_modules/lodash/reduce.js","webpack://@elyra/ui-components/../../node_modules/lodash/sortBy.js","webpack://@elyra/ui-components/../../node_modules/lodash/times.js","webpack://@elyra/ui-components/../../node_modules/lodash/toFinite.js","webpack://@elyra/ui-components/../../node_modules/lodash/toInteger.js","webpack://@elyra/ui-components/../../node_modules/lodash/toNumber.js","webpack://@elyra/ui-components/../../node_modules/lodash/toPlainObject.js","webpack://@elyra/ui-components/../../node_modules/lodash/transform.js","webpack://@elyra/ui-components/../../node_modules/lodash/union.js","webpack://@elyra/ui-components/../../node_modules/lodash/uniq.js","webpack://@elyra/ui-components/../../node_modules/lodash/uniqWith.js","webpack://@elyra/ui-components/../../node_modules/lodash/without.js","webpack://@elyra/ui-components/../../node_modules/validate.io-array/lib/index.js","webpack://@elyra/ui-components/../../node_modules/validate.io-function/lib/index.js","webpack://@elyra/ui-components/../../node_modules/validate.io-integer-array/lib/index.js","webpack://@elyra/ui-components/../../node_modules/validate.io-integer/lib/index.js","webpack://@elyra/ui-components/../../node_modules/validate.io-number/lib/index.js"],"sourcesContent":["import cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { ErrorSchema } from './types';\nimport { ERRORS_KEY } from './constants';\n\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\n * get the result and/or reset all the errors back to an initial set and start again.\n */\nexport default class ErrorSchemaBuilder<T = any> {\n  /** The error schema being built\n   *\n   * @private\n   */\n  private errorSchema: ErrorSchema<T> = {};\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   */\n  constructor(initialSchema?: ErrorSchema<T>) {\n    this.resetAllErrors(initialSchema);\n  }\n\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\n   */\n  get ErrorSchema() {\n    return this.errorSchema;\n  }\n\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The error block for the given `pathOfError` or the root if not provided\n   * @private\n   */\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n    return errorBlock;\n  }\n\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    let errorsList = get(errorBlock, ERRORS_KEY);\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      errorsList.push(...errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n    return this;\n  }\n\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\n   * the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  clearErrors(pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  }\n}\n","import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (schema.additionalItems === true) {\n    console.warn('additionalItems=true is currently not supported');\n  }\n  return isObject(schema.additionalItems);\n}\n","/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === '') {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === 'number' && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\nimport getUiOptions from './getUiOptions';\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, S, F> = {},\n  formData?: T\n) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n","/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITIONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\nexport const ALL_OF_KEY = 'allOf';\nexport const ANY_OF_KEY = 'anyOf';\nexport const CONST_KEY = 'const';\nexport const DEFAULT_KEY = 'default';\nexport const DEFINITIONS_KEY = 'definitions';\nexport const DEPENDENCIES_KEY = 'dependencies';\nexport const ENUM_KEY = 'enum';\nexport const ERRORS_KEY = '__errors';\nexport const ID_KEY = '$id';\nexport const IF_KEY = 'if';\nexport const ITEMS_KEY = 'items';\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\nexport const NAME_KEY = '$name';\nexport const ONE_OF_KEY = 'oneOf';\nexport const PROPERTIES_KEY = 'properties';\nexport const REQUIRED_KEY = 'required';\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\nexport const REF_KEY = '$ref';\n/**\n * @deprecated Replace with correctly spelled constant `RJSF_ADDITIONAL_PROPERTIES_FLAG`\n */\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nexport const RJSF_ADDITIONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\nexport const UI_FIELD_KEY = 'ui:field';\nexport const UI_WIDGET_KEY = 'ui:widget';\nexport const UI_OPTIONS_KEY = 'ui:options';\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\n","import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\n\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n *\n * @param formData - The form data around which the error handler is created\n * @returns - A `FormValidation` object based on the `formData` structure\n */\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\n  const handler: FieldValidation = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // 'errors' (see `utils.toErrorSchema`).\n    [ERRORS_KEY]: [],\n    addError(message: string) {\n      this[ERRORS_KEY]!.push(message);\n    },\n  };\n  if (Array.isArray(formData)) {\n    return formData.reduce((acc, value, key) => {\n      return { ...acc, [key]: createErrorHandler(value) };\n    }, handler);\n  }\n  if (isPlainObject(formData)) {\n    const formObject: GenericObjectType = formData as GenericObjectType;\n    return Object.keys(formObject).reduce((acc, key) => {\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\n    }, handler as FormValidation<T>);\n  }\n  return handler as FormValidation<T>;\n}\n","import deepEquals from './deepEquals';\nimport {\n  ErrorSchema,\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GlobalUISchemaOptions,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from './types';\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n} from './schema';\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements SchemaUtilsType<T, S, F>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S, F>;\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\n   */\n  constructor(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\n  ) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior = {}\n  ): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return (\n      this.validator !== validator ||\n      !deepEquals(this.rootSchema, rootSchema) ||\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\n    );\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S, F>(\n      this.validator,\n      schema,\n      formData,\n      this.rootSchema,\n      includeUndefinedValues,\n      this.experimental_defaultFormStateBehavior\n    );\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(\n    formData: T | undefined,\n    options: S[],\n    selectedOption?: number,\n    discriminatorField?: string\n  ): number {\n    return getClosestMatchingOption<T, S, F>(\n      this.validator,\n      this.rootSchema,\n      formData,\n      options,\n      selectedOption,\n      discriminatorField\n    );\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData?: T) {\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\n  }\n\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  experimental_defaultFormStateBehavior = {}\n): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\n}\n","/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURILike: string) {\n  // check if is dataURI\n  if (dataURILike.indexOf('data:') === -1) {\n    throw new Error('File is invalid: URI must be a dataURI');\n  }\n  const dataURI = dataURILike.slice(5);\n  // split the dataURI into media and base64, with the base64 signature\n  const splitted = dataURI.split(';base64,');\n  // if the base64 signature is not present, the latter part will become empty\n  if (splitted.length !== 2) {\n    throw new Error('File is invalid: dataURI must be base64');\n  }\n  // extract the mime type, media parameters including the name, and the base64 string\n  const [media, base64] = splitted;\n  const [mime, ...mediaparams] = media.split(';');\n  const type = mime || '';\n\n  // extract the name from the parameters\n  const name = decodeURI(\n    // parse the parameters into key-value pairs, find a key, and extract a value\n    // if no key is found, then the name is unknown\n    mediaparams.map((param) => param.split('=')).find(([key]) => key === 'name')?.[1] || 'unknown'\n  );\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(base64);\n    const array = new Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      array[i] = binary.charCodeAt(i);\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], { type });\n\n    return { blob, name };\n  } catch (error) {\n    throw new Error('File is invalid: ' + (error as Error).message);\n  }\n}\n","import pad from './pad';\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns a list of options for a date range between `start` and `stop`. If the start date is greater than the end\n * date, then the date range is reversed. If `start` and `stop` are negative numbers (or zero), then they will be\n * treated as relative to the current year.\n *\n * @param start - The starting point of the date range\n * @param stop - The ending point of the date range\n * @returns - The list of EnumOptionsType for the date range between `start` and `stop`\n * @throws - Error when `start` and `stop` aren't both <= 0 or > 0\n */\nexport default function dateRangeOptions<S extends StrictRJSFSchema = RJSFSchema>(\n  start: number,\n  stop: number\n): EnumOptionsType<S>[] {\n  if (start <= 0 && stop <= 0) {\n    start = new Date().getFullYear() + start;\n    stop = new Date().getFullYear() + stop;\n  } else if (start < 0 || stop < 0) {\n    throw new Error(`Both start (${start}) and stop (${stop}) must both be <= 0 or > 0, got one of each`);\n  }\n  if (start > stop) {\n    return dateRangeOptions<S>(stop, start).reverse();\n  }\n  const options: EnumOptionsType<S>[] = [];\n  for (let i = start; i <= stop; i++) {\n    options.push({ value: i, label: pad(i, 2) });\n  }\n  return options;\n}\n","import isEqualWith from 'lodash/isEqualWith';\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === 'function' && typeof other === 'function') {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n","import { TranslatableString } from './enums';\nimport replaceStringParameters from './replaceStringParameters';\n\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\n * `%2`, etc. replacement specifiers.\n *\n * @param stringToTranslate - The `TranslatableString` value to convert to english\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\n */\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\n  return replaceStringParameters(stringToTranslate, params);\n}\n","import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\n * is returned, otherwise the `selected` value is returned.\n *\n * @param valueIndex - The index of the value to be removed from the selected list or single value\n * @param selected - The current (list of) selected value(s)\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\n *        undefined, otherwise `selected`.\n */\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (Array.isArray(selected)) {\n    return selected.filter((v) => !isEqual(v, value));\n  }\n  return isEqual(value, selected) ? undefined : selected;\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\n\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\n * returned.\n *\n * @param value - The single value or list of values for which indexes are desired\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\n *        of indexes for (each of) the value(s) in `value`.\n */\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  multiple = false\n): string | string[] | undefined {\n  const selectedIndexes: string[] = allEnumOptions\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\n    .filter((opt) => typeof opt !== 'undefined') as string[];\n  if (!multiple) {\n    return selectedIndexes[0];\n  }\n  return selectedIndexes;\n}\n","import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Determines whether the given `value` is (one of) the `selected` value(s).\n *\n * @param value - The value being checked to see if it is selected\n * @param selected - The current selected value or list of values\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\n */\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'],\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\n) {\n  if (Array.isArray(selected)) {\n    return selected.some((sel) => isEqual(sel, value));\n  }\n  return isEqual(selected, value);\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport isNil from 'lodash/isNil';\n\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected: EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n) {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (!isNil(value)) {\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\n    const all = allEnumOptions.map(({ value: val }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\n * valid values or in the worst case, an empty array.\n *\n * @param valueIndex - The index(es) of the value(s) that should be returned\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\n *        `emptyValue` or an empty list.\n */\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number | Array<string | number>,\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  emptyValue?: EnumOptionsType<S>['value']\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  if (Array.isArray(valueIndex)) {\n    return (\n      valueIndex\n        .map((index) => enumOptionsValueForIndex(index, allEnumOptions))\n        // Since the recursive call returns `emptyValue` when we get a bad option, only filter those out\n        .filter((val) => val !== emptyValue)\n    );\n  }\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\n  const option = allEnumOptions[index];\n  return option ? option.value : emptyValue;\n}\n","/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\n * parameters is important because some languages may choose to put the second parameter before the first in its\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\n */\nexport enum TranslatableString {\n  /** Fallback title of an array item, used by ArrayField */\n  ArrayItemTitle = 'Item',\n  /** Missing items reason, used by ArrayField */\n  MissingItems = 'Missing items definition',\n  /** Yes label, used by BooleanField */\n  YesLabel = 'Yes',\n  /** No label, used by BooleanField */\n  NoLabel = 'No',\n  /** Close label, used by ErrorList */\n  CloseLabel = 'Close',\n  /** Errors label, used by ErrorList */\n  ErrorsLabel = 'Errors',\n  /** New additionalProperties string default value, used by ObjectField */\n  NewStringDefault = 'New Value',\n  /** Add button title, used by AddButton */\n  AddButton = 'Add',\n  /** Add button title, used by AddButton */\n  AddItemButton = 'Add Item',\n  /** Copy button title, used by IconButton */\n  CopyButton = 'Copy',\n  /** Move down button title, used by IconButton */\n  MoveDownButton = 'Move down',\n  /** Move up button title, used by IconButton */\n  MoveUpButton = 'Move up',\n  /** Remove button title, used by IconButton */\n  RemoveButton = 'Remove',\n  /** Now label, used by AltDateWidget */\n  NowLabel = 'Now',\n  /** Clear label, used by AltDateWidget */\n  ClearLabel = 'Clear',\n  /** Aria date label, used by DateWidget */\n  AriaDateLabel = 'Select a date',\n  /** File preview label, used by FileWidget */\n  PreviewLabel = 'Preview',\n  /** Decrement button aria label, used by UpDownWidget */\n  DecrementAriaLabel = 'Decrease value by 1',\n  /** Increment button aria label, used by UpDownWidget */\n  IncrementAriaLabel = 'Increase value by 1',\n  // Strings with replaceable parameters\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\n  UnknownFieldType = 'Unknown field type %1',\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\n  OptionPrefix = 'Option %1',\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\n   * MultiSchemaField\n   */\n  TitleOptionPrefix = '%1 option %2',\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\n  KeyLabel = '%1 Key',\n  // Strings with replaceable parameters AND/OR that support markdown and html\n  /** Invalid object field configuration as provided by the ObjectField.\n   * NOTE: Use markdown notation rather than html tags.\n   */\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: _%2_.',\n  /** Unsupported field schema, used by UnsupportedField */\n  UnsupportedField = 'Unsupported field schema.',\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField.\n   * NOTE: Use markdown notation rather than html tags.\n   */\n  UnsupportedFieldWithId = 'Unsupported field schema for field `%1`.',\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField.\n   * NOTE: Use markdown notation rather than html tags.\n   */\n  UnsupportedFieldWithReason = 'Unsupported field schema: _%1_.',\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\n   * as provided by UnsupportedField.\n   * NOTE: Use markdown notation rather than html tags.\n   */\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field `%1`: _%2_.',\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\n   * provided by FileWidget\n   */\n  FilesInfo = '**%1** (%2, %3 bytes)',\n}\n","import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\n\nimport { REF_KEY } from './constants';\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, recursively look up and return the\n * sub-schema using the path provided by that reference. If `#` is not the first character of the reference, the path\n * does not exist in the schema, or the reference resolves circularly back to itself, then throw an Error.\n * Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference could be resolved\n */\nexport function findSchemaDefinitionRecursive<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S,\n  recurseList: string[] = []\n): S {\n  const ref = $ref || '';\n  let decodedRef;\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    decodedRef = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, decodedRef);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const nextRef = current[REF_KEY];\n  if (nextRef) {\n    // Check for circular references.\n    if (recurseList.includes(nextRef)) {\n      if (recurseList.length === 1) {\n        throw new Error(`Definition for ${$ref} is a circular reference`);\n      }\n      const [firstRef, ...restRefs] = recurseList;\n      const circularPath = [...restRefs, ref, firstRef].join(' -> ');\n      throw new Error(`Definition for ${firstRef} contains a circular reference through ${circularPath}`);\n    }\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinitionRecursive<S>(theRef, rootSchema, [...recurseList, ref]);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, the path does not exist in\n * the schema, or the reference resolves circularly back to itself, then throw an Error. Otherwise return the\n * sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference could be resolved\n */\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S\n): S {\n  const recurseList: string[] = [];\n  return findSchemaDefinitionRecursive($ref, rootSchema, recurseList);\n}\n","import { type DateObject } from './types';\n\n/** Available options for re-ordering date input element */\nexport type DateElementFormat = 'DMY' | 'MDY' | 'YMD';\n\n/** Type describing format of DateElement prop */\ntype DateElementProp = {\n  type: string;\n  range: [number, number];\n  value: number | undefined;\n};\n\n/** Given date & time information with optional yearRange & format, returns props for DateElement\n *\n * @param date - Object containing date with optional time information\n * @param time - Determines whether to include time or not\n * @param [yearRange=[1900, new Date().getFullYear() + 2]] - Controls the list of years to be displayed\n * @param [format='YMD'] - Controls the order in which day, month and year input element will be displayed\n * @returns Array of props for DateElement\n */\n\nexport default function getDateElementProps(\n  date: DateObject,\n  time: boolean,\n  yearRange: [number, number] = [1900, new Date().getFullYear() + 2],\n  format: DateElementFormat = 'YMD'\n) {\n  const { day, month, year, hour, minute, second } = date;\n\n  const dayObj: DateElementProp = { type: 'day', range: [1, 31], value: day };\n  const monthObj: DateElementProp = { type: 'month', range: [1, 12], value: month };\n  const yearObj: DateElementProp = { type: 'year', range: yearRange, value: year };\n\n  const dateElementProp: DateElementProp[] = [];\n  switch (format) {\n    case 'MDY':\n      dateElementProp.push(monthObj, dayObj, yearObj);\n      break;\n    case 'DMY':\n      dateElementProp.push(dayObj, monthObj, yearObj);\n      break;\n    case 'YMD':\n    default:\n      dateElementProp.push(yearObj, monthObj, dayObj);\n  }\n\n  if (time) {\n    dateElementProp.push(\n      { type: 'hour', range: [0, 23], value: hour },\n      { type: 'minute', range: [0, 59], value: minute },\n      { type: 'second', range: [0, 59], value: second }\n    );\n  }\n\n  return dateElementProp;\n}\n","import get from 'lodash/get';\nimport isString from 'lodash/isString';\n\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\n *\n * @param schema - The schema from which the discriminator is potentially obtained\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\n */\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  let discriminator: string | undefined;\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\n  if (isString(maybeString)) {\n    discriminator = maybeString;\n  } else if (maybeString !== undefined) {\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\n  }\n  return discriminator;\n}\n","import rangeSpec from './rangeSpec';\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, S, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || 'text',\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === 'number') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = 'any';\n      }\n    } else if (schema.type === 'integer') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n","import get from 'lodash/get';\nimport { PROPERTIES_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\n *\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or undefined if there is no match\n */\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\n  formData: T | undefined,\n  options: S[],\n  discriminatorField?: string\n): number | undefined {\n  if (formData && discriminatorField) {\n    const value = get(formData, discriminatorField);\n\n    if (value === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < options.length; i++) {\n      const option = options[i];\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n\n      if (discriminator.type === 'object' || discriminator.type === 'array') {\n        continue;\n      }\n\n      if (discriminator.const === value) {\n        return i;\n      }\n\n      if (discriminator.enum?.includes(value)) {\n        return i;\n      }\n    }\n  }\n\n  return;\n}\n","import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type)) {\n    if (type.length === 2 && type.includes('null')) {\n      type = type.find((type) => type !== 'null');\n    } else {\n      type = type[0];\n    }\n  }\n\n  return type;\n}\n","import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\nimport getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: 'Submit',\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n","import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, S, F>,\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\n  const { templates } = registry;\n  if (name === 'ButtonTemplates') {\n    return templates[name];\n  }\n  return (\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\n  );\n}\n","import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\nimport isObject from './isObject';\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\n */\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  uiSchema: UiSchema<T, S, F> = {},\n  globalOptions: GlobalUISchemaOptions = {}\n): UIOptionsType<T, S, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf('ui:') === 0)\n    .reduce(\n      (options, key) => {\n        const value = uiSchema[key];\n        if (key === UI_WIDGET_KEY && isObject(value)) {\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\n          return options;\n        }\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\n          return { ...options, ...value };\n        }\n        return { ...options, [key.substring(3)]: value };\n      },\n      { ...globalOptions }\n    );\n}\n","import { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\nimport getSchemaType from './getSchemaType';\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget',\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget',\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget',\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  AWidget: Widget<T, S, F>\n) {\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === 'function' ||\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n","/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (typeof value === 'string') {\n    return 'string';\n  }\n  if (value == null) {\n    return 'null';\n  }\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n  if (!isNaN(value)) {\n    return 'number';\n  }\n  if (typeof value === 'object') {\n    return 'object';\n  }\n  // Default to string if we can't figure it out\n  return 'string';\n}\n","import getWidget from './getWidget';\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\n      return false;\n    }\n    throw e;\n  }\n}\n","import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** JS has no built-in hashing function, so rolling our own\n *  based on Java's hashing fn:\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\n *\n * @param string - The string for which to get the hash\n * @returns - The resulting hash of the string in hex format\n */\nfunction hashString(string: string): string {\n  let hash = 0;\n  for (let i = 0; i < string.length; i += 1) {\n    const chr = string.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash.toString(16);\n}\n\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\n * in consistent order before stringify to prevent different hash ids for the same schema.\n *\n * @param schema - The schema for which the hash is desired\n * @returns - The string obtained from the hash of the stringified schema\n */\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const allKeys = new Set<string>();\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\n}\n","import isString from 'lodash/isString';\n\nimport { IdSchema } from './types';\nimport { ID_KEY } from './constants';\n\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param suffix - The suffix to append to the id\n */\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\n  const theId = isString(id) ? id : id[ID_KEY];\n  return `${theId}__${suffix}`;\n}\n/** Return a consistent `id` for the field description element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field description element from the given `id`\n */\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'description');\n}\n\n/** Return a consistent `id` for the field error element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field error element from the given `id`\n */\nexport function errorId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'error');\n}\n\n/** Return a consistent `id` for the field examples element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field examples element from the given `id`\n */\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'examples');\n}\n\n/** Return a consistent `id` for the field help element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field help element from the given `id`\n */\nexport function helpId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'help');\n}\n\n/** Return a consistent `id` for the field title element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field title element from the given `id`\n */\nexport function titleId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'title');\n}\n\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\n * element.\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\n */\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\n}\n\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\n *\n * @param id - The id of the parent component for the option\n * @param optionIndex - The index of the option for which the id is desired\n * @returns - An id for the option index based on the parent `id`\n */\nexport function optionId(id: string, optionIndex: number) {\n  return `${id}-${optionIndex}`;\n}\n","import allowAdditionalItems from './allowAdditionalItems';\nimport asNumber from './asNumber';\nimport canExpand from './canExpand';\nimport createErrorHandler from './createErrorHandler';\nimport createSchemaUtils from './createSchemaUtils';\nimport dataURItoBlob from './dataURItoBlob';\nimport dateRangeOptions from './dateRangeOptions';\nimport deepEquals from './deepEquals';\nimport englishStringTranslator from './englishStringTranslator';\nimport enumOptionsDeselectValue from './enumOptionsDeselectValue';\nimport enumOptionsIndexForValue from './enumOptionsIndexForValue';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\nimport enumOptionsSelectValue from './enumOptionsSelectValue';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\nimport findSchemaDefinition from './findSchemaDefinition';\nimport getDateElementProps, { type DateElementFormat } from './getDateElementProps';\nimport getDiscriminatorFieldFromSchema from './getDiscriminatorFieldFromSchema';\nimport getInputProps from './getInputProps';\nimport getSchemaType from './getSchemaType';\nimport getSubmitButtonOptions from './getSubmitButtonOptions';\nimport getTemplate from './getTemplate';\nimport getUiOptions from './getUiOptions';\nimport getWidget from './getWidget';\nimport guessType from './guessType';\nimport hashForSchema from './hashForSchema';\nimport hasWidget from './hasWidget';\nimport { ariaDescribedByIds, descriptionId, errorId, examplesId, helpId, optionId, titleId } from './idGenerators';\nimport isConstant from './isConstant';\nimport isCustomWidget from './isCustomWidget';\nimport isFixedItems from './isFixedItems';\nimport isObject from './isObject';\nimport labelValue from './labelValue';\nimport localToUTC from './localToUTC';\nimport mergeDefaultsWithFormData from './mergeDefaultsWithFormData';\nimport mergeObjects from './mergeObjects';\nimport mergeSchemas from './mergeSchemas';\nimport optionsList from './optionsList';\nimport orderProperties from './orderProperties';\nimport pad from './pad';\nimport parseDateString from './parseDateString';\nimport rangeSpec from './rangeSpec';\nimport replaceStringParameters from './replaceStringParameters';\nimport schemaRequiresTrueValue from './schemaRequiresTrueValue';\nimport shouldRender from './shouldRender';\nimport toConstant from './toConstant';\nimport toDateString from './toDateString';\nimport toErrorList from './toErrorList';\nimport toErrorSchema from './toErrorSchema';\nimport unwrapErrorHandler from './unwrapErrorHandler';\nimport utcToLocal from './utcToLocal';\nimport validationDataMerge from './validationDataMerge';\nimport withIdRefPrefix from './withIdRefPrefix';\nimport getOptionMatchingSimpleDiscriminator from './getOptionMatchingSimpleDiscriminator';\n\nexport * from './types';\nexport * from './enums';\n\nexport * from './constants';\nexport * from './parser';\nexport * from './schema';\n\nexport {\n  allowAdditionalItems,\n  ariaDescribedByIds,\n  asNumber,\n  canExpand,\n  createErrorHandler,\n  createSchemaUtils,\n  DateElementFormat,\n  dataURItoBlob,\n  dateRangeOptions,\n  deepEquals,\n  descriptionId,\n  englishStringTranslator,\n  enumOptionsDeselectValue,\n  enumOptionsIndexForValue,\n  enumOptionsIsSelected,\n  enumOptionsSelectValue,\n  enumOptionsValueForIndex,\n  errorId,\n  examplesId,\n  ErrorSchemaBuilder,\n  findSchemaDefinition,\n  getDateElementProps,\n  getDiscriminatorFieldFromSchema,\n  getInputProps,\n  getOptionMatchingSimpleDiscriminator,\n  getSchemaType,\n  getSubmitButtonOptions,\n  getTemplate,\n  getUiOptions,\n  getWidget,\n  guessType,\n  hasWidget,\n  hashForSchema,\n  helpId,\n  isConstant,\n  isCustomWidget,\n  isFixedItems,\n  isObject,\n  labelValue,\n  localToUTC,\n  mergeDefaultsWithFormData,\n  mergeObjects,\n  mergeSchemas,\n  optionId,\n  optionsList,\n  orderProperties,\n  pad,\n  parseDateString,\n  rangeSpec,\n  replaceStringParameters,\n  schemaRequiresTrueValue,\n  shouldRender,\n  titleId,\n  toConstant,\n  toDateString,\n  toErrorList,\n  toErrorSchema,\n  unwrapErrorHandler,\n  utcToLocal,\n  validationDataMerge,\n  withIdRefPrefix,\n};\n","import { CONST_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\n}\n","import getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\n  );\n}\n","import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\n}\n","/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== 'undefined' && thing instanceof File) {\n    return false;\n  }\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\n    return false;\n  }\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n","import { ReactElement } from 'react';\n\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\n * themes require may `false` and others may require an empty string.\n *\n * @param [label] - The label string or component to render when not hidden\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\n */\n\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: ''): undefined | string;\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: false): undefined | false | string;\nexport default function labelValue(label?: ReactElement, hideLabel?: boolean, fallback?: ''): undefined | ReactElement;\nexport default function labelValue(\n  label?: ReactElement,\n  hideLabel?: boolean,\n  fallback?: false\n): undefined | false | ReactElement;\nexport default function labelValue(\n  label?: string | ReactElement,\n  hideLabel?: boolean,\n  fallback?: false | ''\n): undefined | false | string | ReactElement {\n  return hideLabel ? fallback : label;\n}\n","/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n","import get from 'lodash/get';\n\nimport isObject from './isObject';\nimport { GenericObjectType } from '../src';\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\n *     which case the extras are appended onto the end of the form data\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param [defaults] - The defaults to merge\n * @param [formData] - The form data into which the defaults will be merged\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(\n  defaults?: T,\n  formData?: T,\n  mergeExtraArrayDefaults = false\n): T | undefined {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\n      }\n      return value;\n    });\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\n      mapped.push(...defaultsArray.slice(mapped.length));\n    }\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\n        defaults ? get(defaults, key) : {},\n        get(formData, key),\n        mergeExtraArrayDefaults\n      );\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n","import isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\n *          NOTE: Uses shallow comparison for the duplicate checking.\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays: boolean | 'preventDuplicates' = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      let toMerge = right;\n      if (concatArrays === 'preventDuplicates') {\n        toMerge = right.reduce((result, value) => {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n          return result;\n        }, []);\n      }\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n","import union from 'lodash/union';\n\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n","import toConstant from './toConstant';\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema, FormContextType, UiSchema } from './types';\nimport getUiOptions from './getUiOptions';\n\n/** Gets the list of options from the `schema`. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value. If a `uiSchema` is provided\n * and it has the `ui:enumNames` matched with `enum` or it has an associated `oneOf` or `anyOf` with a list of objects\n * containing `ui:title` then the UI schema values will replace the values from the schema.\n *\n * @param schema - The schema from which to extract the options list\n * @param [uiSchema] - The optional uiSchema from which to get alternate labels for the options\n * @returns - The list of options from the schema\n */\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema, T = any, F extends FormContextType = any>(\n  schema: S,\n  uiSchema?: UiSchema<T, S, F>\n): EnumOptionsType<S>[] | undefined {\n  // TODO flip generics to move T first in v6\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n  if (schema.enum) {\n    let enumNames: string[] | undefined;\n    if (uiSchema) {\n      const { enumNames: uiEnumNames } = getUiOptions<T, S, F>(uiSchema);\n      enumNames = uiEnumNames;\n    }\n    if (!enumNames && schemaWithEnumNames.enumNames) {\n      // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n      // Cast the type to include enumNames so the feature still works.\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          'The \"enumNames\" property in the schema is deprecated and will be removed in a future major release. Use the \"ui:enumNames\" property in the uiSchema instead.'\n        );\n      }\n      enumNames = schemaWithEnumNames.enumNames;\n    }\n    return schema.enum.map((value, i) => {\n      const label = enumNames?.[i] || String(value);\n      return { label, value };\n    });\n  }\n  let altSchemas: S['anyOf'] | S['oneOf'] = undefined;\n  let altUiSchemas: UiSchema<T, S, F> | undefined = undefined;\n  if (schema.anyOf) {\n    altSchemas = schema.anyOf;\n    altUiSchemas = uiSchema?.anyOf;\n  } else if (schema.oneOf) {\n    altSchemas = schema.oneOf;\n    altUiSchemas = uiSchema?.oneOf;\n  }\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef, index) => {\n      const { title } = getUiOptions<T, S, F>(altUiSchemas?.[index]);\n      const aSchema = aSchemaDef as S;\n      const value = toConstant(aSchema);\n      const label = title || aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n","import { GenericObjectType } from './types';\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n","/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = '0' + s;\n  }\n  return s;\n}\n","import { DateObject } from './types';\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error('Unable to parse date ' + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n","import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ID_KEY } from '../constants';\nimport hashForSchema from '../hashForSchema';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from '../types';\n\n/** The type of the map of schema hash to schema\n */\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\n  [hash: string]: S;\n};\n\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\n */\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The rootSchema provided during construction of the class */\n  readonly rootSchema: S;\n\n  /** The map of schemas encountered by the ParserValidator */\n  schemaMap: SchemaMap<S> = {};\n\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\n   * first.\n   *\n   * @param rootSchema - The root schema against which this validator will be executed\n   */\n  constructor(rootSchema: S) {\n    this.rootSchema = rootSchema;\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\n  }\n\n  /** Resets the internal AJV validator to clear schemas from it. Can be helpful for resetting the validator for tests.\n   */\n  reset() {\n    this.schemaMap = {};\n  }\n\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\n   * associated with it's `hash` for future use (by a schema compiler).\n   *\n   * @param schema - The schema which is to be added to the map\n   * @param hash - The hash value at which to map the schema\n   */\n  addSchema(schema: S, hash: string) {\n    const key = get(schema, ID_KEY, hash);\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\n    const existing = this.schemaMap[key];\n    if (!existing) {\n      this.schemaMap[key] = identifiedSchema;\n    } else if (!isEqual(existing, identifiedSchema)) {\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\n      throw new Error(\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\n      );\n    }\n  }\n\n  /** Returns the current `schemaMap` to the caller\n   */\n  getSchemaMap() {\n    return this.schemaMap;\n  }\n\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\n   * the `rootSchema` is not the same as the root schema provided during construction.\n   *\n   * @param schema - The schema to record in the `schemaMap`\n   * @param _formData - The formData parameter that is ignored\n   * @param rootSchema - The root schema associated with the schema\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\n   */\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\n    if (!isEqual(rootSchema, this.rootSchema)) {\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\n    }\n    this.addSchema(schema, hashForSchema<S>(schema));\n\n    return false;\n  }\n\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\n   *\n   * @param _schema - The schema parameter that is ignored\n   * @param _formData - The formData parameter that is ignored\n   */\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\n   *\n   * @param _errorSchema - The error schema parameter that is ignored\n   * @param _fieldPath - The field path parameter that is ignored\n   */\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\n   * called\n   *\n   * @param _formData - The formData parameter that is ignored\n   * @param _schema - The schema parameter that is ignored\n   * @param _customValidate - The customValidate parameter that is ignored\n   * @param _transformErrors - The transformErrors parameter that is ignored\n   * @param _uiSchema - The uiSchema parameter that is ignored\n   */\n  validateFormData(\n    _formData: T,\n    _schema: S,\n    _customValidate?: CustomValidator<T, S, F>,\n    _transformErrors?: ErrorTransformer<T, S, F>,\n    _uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\n  }\n}\n","import schemaParser from './schemaParser';\nimport { SchemaMap } from './ParserValidator';\n\nexport type { SchemaMap };\n\nexport { schemaParser };\n","import forEach from 'lodash/forEach';\nimport isEqual from 'lodash/isEqual';\n\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\nimport ParserValidator, { SchemaMap } from './ParserValidator';\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\n\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\n *\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\n * @param rootSchema - The root schema from which the schema parsing began\n * @param schema - The current schema element being parsed\n */\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ParserValidator<T, S, F>,\n  recurseList: S[],\n  rootSchema: S,\n  schema: S\n) {\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\n  schemas.forEach((schema) => {\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\n    if (sameSchemaIndex === -1) {\n      recurseList.push(schema);\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\n      allOptions.forEach((s) => {\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\n          forEach(schema[PROPERTIES_KEY], (value) => {\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\n          });\n        }\n      });\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\n      }\n    }\n  });\n}\n\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\n * the hash of the schema to schema/sub-schema.\n *\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\n * @returns - The `SchemaMap` of all schemas that were parsed\n */\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  rootSchema: S\n): SchemaMap<S> {\n  const validator = new ParserValidator<T, S, F>(rootSchema);\n  const recurseList: S[] = [];\n\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\n\n  return validator.getSchemaMap();\n}\n","import { RangeSpecType, StrictRJSFSchema } from './types';\nimport { RJSFSchema } from './types';\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n","/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\n *\n * @param inputString - The string which will be potentially updated with replacement parameters\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The updated string with any replacement specifiers replaced\n */\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\n  let output = inputString;\n  if (Array.isArray(params)) {\n    const parts = output.split(/(%\\d)/);\n    params.forEach((param, index) => {\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\n      if (partIndex >= 0) {\n        parts[partIndex] = param;\n      }\n    });\n    output = parts.join('');\n  }\n  return output;\n}\n","import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\n            return (\n              score +\n              getClosestMatchingOption<T, S, F>(\n                validator,\n                rootSchema,\n                formValue,\n                get(value, key) as S[],\n                -1,\n                discriminator\n              )\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1,\n  discriminatorField?: string\n): number {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map((option) => {\n    return resolveAllReferences<S>(option, rootSchema, []);\n  });\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  const scoreCount = new Set<number>();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      const option = resolvedOptions[index];\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      scoreCount.add(score);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n\n  return bestIndex;\n}\n","import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport {\n  ANY_OF_KEY,\n  DEFAULT_KEY,\n  DEPENDENCIES_KEY,\n  PROPERTIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  ALL_OF_KEY,\n} from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport {\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  isParentRequired?: boolean,\n  requiredFields: string[] = [],\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\n) {\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n\n      // If emptyObjectFields 'skipEmptyDefaults' store computedDefault if it's a non-empty object(e.g. not {})\n      if (emptyObjectFields === 'skipEmptyDefaults') {\n        if (!isEmpty(computedDefault)) {\n          obj[key] = computedDefault;\n        }\n      }\n      // Else store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      else if (\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\n      ) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n      // Condition 1: computedDefault is not undefined\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults) or if the key is a required field\n      computedDefault !== undefined &&\n      (emptyObjectFields === 'populateAllDefaults' ||\n        emptyObjectFields === 'skipEmptyDefaults' ||\n        requiredFields.includes(key))\n    ) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\n  parentDefaults?: T;\n  rootSchema?: S;\n  rawFormData?: T;\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\n  _recurseList?: string[];\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  required?: boolean;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  {\n    parentDefaults,\n    rawFormData,\n    rootSchema = {} as S,\n    includeUndefinedValues = false,\n    _recurseList = [],\n    experimental_defaultFormStateBehavior = undefined,\n    required,\n  }: ComputeDefaultsProps<T, S> = {}\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute: S | null = null;\n  let updatedRecurseList = _recurseList;\n\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName!)) {\n      updatedRecurseList = _recurseList.concat(refName!);\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(validator, itemSchema, {\n        rootSchema,\n        includeUndefinedValues,\n        _recurseList,\n        experimental_defaultFormStateBehavior,\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rawFormData: formData as T,\n        required,\n      })\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    const { oneOf, ...remaining } = schema;\n    if (oneOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        oneOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  } else if (ANY_OF_KEY in schema) {\n    const { anyOf, ...remaining } = schema;\n    if (anyOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        anyOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  }\n\n  if (schemaToCompute) {\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults as T | undefined,\n      rawFormData: formData as T,\n      required,\n    });\n  }\n\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object': {\n      // This is a custom addition that fixes this issue:\n      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\n      const retrievedSchema =\n        experimental_defaultFormStateBehavior?.allOf === 'populateDefaults' && ALL_OF_KEY in schema\n          ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData)\n          : schema;\n      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(\n        (acc: GenericObjectType, key: string) => {\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          const computedDefault = computeDefaults<T, S, F>(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          maybeAddDefaultToObject<T>(\n            acc,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            retrievedSchema.required,\n            experimental_defaultFormStateBehavior\n          );\n          return acc;\n        },\n        {}\n      ) as T;\n      if (retrievedSchema.additionalProperties) {\n        // as per spec additionalProperties may be either schema or boolean\n        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)\n          ? retrievedSchema.additionalProperties\n          : {};\n\n        const keys = new Set<string>();\n        if (isObject(defaults)) {\n          Object.keys(defaults as GenericObjectType)\n            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n            .forEach((key) => keys.add(key));\n        }\n        const formDataRequired: string[] = [];\n        Object.keys(formData as GenericObjectType)\n          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n          .forEach((key) => {\n            keys.add(key);\n            formDataRequired.push(key);\n          });\n        keys.forEach((key) => {\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\n          maybeAddDefaultToObject<T>(\n            objectDefaults as GenericObjectType,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            formDataRequired\n          );\n        });\n      }\n      return objectDefaults;\n    }\n    case 'array': {\n      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'never';\n      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';\n      const isSkipEmptyDefaults = experimental_defaultFormStateBehavior?.emptyObjectFields === 'skipEmptyDefaults';\n      const computeSkipPopulate =\n        experimental_defaultFormStateBehavior?.arrayMinItems?.computeSkipPopulate ?? (() => false);\n\n      const emptyDefault = isSkipEmptyDefaults ? undefined : [];\n\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            parentDefaults: item,\n            required,\n          });\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        if (neverPopulate) {\n          defaults = rawFormData;\n        } else {\n          defaults = rawFormData.map((item: T, idx: number) => {\n            return computeDefaults<T, S, F>(validator, schemaItem, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              rawFormData: item,\n              parentDefaults: get(defaults, [idx]),\n              required,\n            });\n          }) as T[];\n        }\n      }\n\n      if (neverPopulate) {\n        return defaults ?? emptyDefault;\n      }\n      if (ignoreMinItemsFlagSet && !required) {\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n        // return form data/defaults\n        return defaults ? defaults : undefined;\n      }\n\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n      if (\n        !schema.minItems ||\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n        computeSkipPopulate<T, S, F>(validator, schema, rootSchema) ||\n        schema.minItems <= defaultsLength\n      ) {\n        return defaults ? defaults : emptyDefault;\n      }\n\n      const defaultEntries: T[] = (defaults || []) as T[];\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n      const fillerDefault = fillerSchema.default;\n\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n        computeDefaults<any, S, F>(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required,\n        })\n      ) as T[];\n      // then fill up the rest with either the item default or empty, up to minItems\n      return defaultEntries.concat(fillerEntries);\n    }\n  }\n\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData,\n  });\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\n  }\n  return formData;\n}\n","import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\nimport getSchemaType from '../getSchemaType';\nimport getUiOptions from '../getUiOptions';\nimport isCustomWidget from '../isCustomWidget';\nimport {\n  FormContextType,\n  GlobalUISchemaOptions,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from '../types';\nimport isFilesArray from './isFilesArray';\nimport isMultiSelect from './isMultiSelect';\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S,\n  globalOptions?: GlobalUISchemaOptions\n): boolean {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType<S>(schema);\n\n  if (schemaType === 'array') {\n    displayLabel =\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === 'object') {\n    displayLabel = false;\n  }\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n","import getMatchingOption from './getMatchingOption';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n * Always returns the first option if there is nothing that matches.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the first matched option or 0 if none is available\n */\nexport default function getFirstMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\n\nimport { PROPERTIES_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n","import getDefaultFormState from './getDefaultFormState';\nimport getDisplayLabel from './getDisplayLabel';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport getMatchingOption from './getMatchingOption';\nimport isFilesArray from './isFilesArray';\nimport isMultiSelect from './isMultiSelect';\nimport isSelect from './isSelect';\nimport mergeValidationData from './mergeValidationData';\nimport retrieveSchema from './retrieveSchema';\nimport sanitizeDataForNewSchema from './sanitizeDataForNewSchema';\nimport toIdSchema from './toIdSchema';\nimport toPathSchema from './toPathSchema';\n\nexport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n};\n","import { UI_WIDGET_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n) {\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\n  }\n  return false;\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\nimport isSelect from './isSelect';\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\n    return false;\n  }\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\n}\n","import isConstant from '../isConstant';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  rootSchema: S = {} as S\n) {\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\n  }\n  return false;\n}\n","import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from '../mergeObjects';\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n *        removed in the next major release.\n */\nexport default function mergeValidationData<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n","import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport merge from 'lodash/merge';\nimport flattenDeep from 'lodash/flattenDeep';\nimport uniq from 'lodash/uniq';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(\n          validator,\n          conditionalSchema as S,\n          rootSchema,\n          formData,\n          expandAllBranches,\n          recurseList\n        )\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchemas = resolveReference<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    formData\n  );\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(\n      validator,\n      schema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    );\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(\n        validator,\n        allOfSubschema as S,\n        rootSchema,\n        formData,\n        expandAllBranches,\n        recurseList\n      )\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal<T, S, F>(\n      validator,\n      updatedSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n  }\n  return [schema];\n}\n\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  rootSchema: S,\n  recurseList: string[]\n): S {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref!)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref!);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const childrenLists: string[][] = [];\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        const childList: string[] = [...recurseList];\n        result[key] = resolveAllReferences(value as S, rootSchema, childList);\n        childrenLists.push(childList);\n      },\n      {} as RJSFSchema\n    );\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\n    };\n  }\n\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  rawFormData?: T,\n  expandAllBranches = false,\n  recurseList: string[] = []\n): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    rawFormData\n  );\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        rawFormData as T\n      );\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const { allOf, ...restOfSchema } = resolvedSchema;\n        return [...(allOf as S[]), restOfSchema as S];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(\n      validator,\n      dependencies,\n      resolvedSchema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    )\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        recurseList,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(\n        validator,\n        remainingDependencies,\n        schema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches,\n    recurseList\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n","import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport { FormContextType, GenericObjectType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\nimport getSchemaType from '../getSchemaType';\n\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param idPrefix - The prefix to use for the id\n * @param idSeparator - The separator to use for the path segments in the id\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `IdSchema` object for the `schema`\n */\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  idPrefix: string,\n  idSeparator: string,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toIdSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        idPrefix,\n        idSeparator,\n        id,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchemaInternal<T, S, F>(\n      validator,\n      get(schema, ITEMS_KEY) as S,\n      idPrefix,\n      idSeparator,\n      id,\n      rootSchema,\n      formData,\n      _recurseList\n    );\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema<T> = { $id } as IdSchema<T>;\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      (idSchema as IdSchema<GenericObjectType>)[name] = toIdSchemaInternal<T, S, F>(\n        validator,\n        isObject(field) ? field : {},\n        idPrefix,\n        idSeparator,\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        _recurseList\n      );\n    }\n  }\n  return idSchema;\n}\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = 'root',\n  idSeparator = '_'\n): IdSchema<T> {\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\n}\n","import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITIONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport { FormContextType, GenericObjectType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name: string,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        name,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n\n  let pathSchema: PathSchema<T> = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema<T>;\n\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\n    const _schema: S = xxxOf![index] as S;\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\n    };\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITIONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;\n\n    if (Array.isArray(schemaItems)) {\n      formData.forEach((element, i: number) => {\n        if (schemaItems[i]) {\n          (pathSchema as PathSchema<T[]>)[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaItems[i] as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else if (schemaAdditionalItems) {\n          (pathSchema as PathSchema<T[]>)[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaAdditionalItems as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else {\n          console.warn(`Unable to generate path schema for \"${name}.${i}\". No schema defined for it`);\n        }\n      });\n    } else {\n      formData.forEach((element, i: number) => {\n        (pathSchema as PathSchema<T[]>)[i] = toPathSchemaInternal<T, S, F>(\n          validator,\n          schemaItems as S,\n          `${name}.${i}`,\n          rootSchema,\n          element,\n          _recurseList\n        );\n      });\n    }\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      (pathSchema as PathSchema<GenericObjectType>)[property] = toPathSchemaInternal<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property]),\n        _recurseList\n      );\n    }\n  }\n  return pathSchema;\n}\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}\n","import React from 'react';\n\nimport deepEquals from './deepEquals';\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n","import { CONST_KEY, ENUM_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error('schema cannot be inferred as a constant');\n}\n","import { DateObject } from './types';\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n","import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\n\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n *\n * @param errorSchema - The `ErrorSchema` instance to convert\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\n */\nexport default function toErrorList<T = any>(\n  errorSchema?: ErrorSchema<T>,\n  fieldPath: string[] = []\n): RJSFValidationError[] {\n  if (!errorSchema) {\n    return [];\n  }\n  let errorList: RJSFValidationError[] = [];\n  if (ERRORS_KEY in errorSchema) {\n    errorList = errorList.concat(\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\n        const property = `.${fieldPath.join('.')}`;\n        return {\n          property,\n          message,\n          stack: `${property} ${message}`,\n        };\n      })\n    );\n  }\n  return Object.keys(errorSchema).reduce((acc, key) => {\n    if (key !== ERRORS_KEY) {\n      const childSchema = (errorSchema as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\n      }\n    }\n    return acc;\n  }, errorList);\n}\n","import toPath from 'lodash/toPath';\n\nimport { ErrorSchema, RJSFValidationError } from './types';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\n\n/** Transforms a rjsf validation errors list:\n * [\n *   {property: '.level1.level2[2].level3', message: 'err a'},\n *   {property: '.level1.level2[2].level3', message: 'err b'},\n *   {property: '.level1.level2[4].level3', message: 'err b'},\n * ]\n * Into an error tree:\n * {\n *   level1: {\n *     level2: {\n *       2: {level3: {errors: ['err a', 'err b']}},\n *       4: {level3: {errors: ['err b']}},\n *     }\n *   }\n * };\n *\n * @param errors - The list of RJSFValidationError objects\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\n */\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\n  const builder = new ErrorSchemaBuilder<T>();\n  if (errors.length) {\n    errors.forEach((error) => {\n      const { property, message } = error;\n      // When the property is the root element, just use an empty array for the path\n      const path = property === '.' ? [] : toPath(property);\n      // If the property is at the root (.level1) then toPath creates\n      // an empty array element at the first index. Remove it.\n      if (path.length > 0 && path[0] === '') {\n        path.splice(0, 1);\n      }\n      if (message) {\n        builder.addErrors(message, path);\n      }\n    });\n  }\n  return builder.ErrorSchema;\n}\n","import type {\n  ButtonHTMLAttributes,\n  ChangeEvent,\n  ComponentType,\n  HTMLAttributes,\n  ReactElement,\n  ReactNode,\n  StyleHTMLAttributes,\n} from 'react';\nimport { JSONSchema7 } from 'json-schema';\n\nimport { TranslatableString } from './enums';\n\n/** The representation of any generic object type, usually used as an intersection on other types to make them more\n * flexible in the properties they support (i.e. anything else)\n */\nexport type GenericObjectType = {\n  [name: string]: any;\n};\n\n/** Map the JSONSchema7 to our own type so that we can easily bump to a more recent version at some future date and only\n * have to update this one type.\n */\nexport type StrictRJSFSchema = JSONSchema7;\n\n/** Allow for more flexible schemas (i.e. draft-2019) than the strict JSONSchema7\n */\nexport type RJSFSchema = StrictRJSFSchema & GenericObjectType;\n\n/** Alias GenericObjectType as FormContextType to allow us to remap this at some future date\n */\nexport type FormContextType = GenericObjectType;\n\n/** Experimental feature that specifies the Array `minItems` default form state behavior\n */\nexport type Experimental_ArrayMinItems = {\n  /** Optional enumerated flag controlling how array minItems are populated, defaulting to `all`:\n   * - `all`: Legacy behavior, populate minItems entries with default values initially and include an empty array when\n   *        no values have been defined.\n   * - `requiredOnly`: Ignore `minItems` on a field when calculating defaults unless the field is required.\n   * - `never`: Ignore `minItems` on a field even the field is required.\n   */\n  populate?: 'all' | 'requiredOnly' | 'never';\n  /** A function that determines whether to skip populating the array with default values based on the provided validator,\n   * schema, and root schema.\n   * If the function returns true, the array will not be populated with default values.\n   * If the function returns false, the array will be populated with default values according to the `populate` option.\n   * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n   * @param schema - The schema for which resolving a condition is desired\n   * @param [rootSchema] - The root schema that will be forwarded to all the APIs\n   * @returns A boolean indicating whether to skip populating the array with default values.\n   */\n  computeSkipPopulate?: <T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n    validator: ValidatorType<T, S, F>,\n    schema: S,\n    rootSchema?: S\n  ) => boolean;\n  /** When `formData` is provided and does not contain `minItems` worth of data, this flag (`false` by default) controls\n   * whether the extra data provided by the defaults is appended onto the existing `formData` items to ensure the\n   * `minItems` condition is met. When false (legacy behavior), only the `formData` provided is merged into the default\n   * form state, even if there are fewer than the `minItems`. When true, the defaults are appended onto the end of the\n   * `formData` until the `minItems` condition is met.\n   */\n  mergeExtraDefaults?: boolean;\n};\n\n/** Experimental features to specify different default form state behaviors. Currently, this affects the\n * handling of optional array fields where `minItems` is set and handling of setting defaults based on the\n * value of `emptyObjectFields`.\n */\nexport type Experimental_DefaultFormStateBehavior = {\n  /** Optional object, that controls how the default form state for arrays with `minItems` is handled. When not provided\n   * it defaults to `{ populate: 'all' }`.\n   */\n  arrayMinItems?: Experimental_ArrayMinItems;\n  /** Optional enumerated flag controlling how empty object fields are populated, defaulting to `populateAllDefaults`:\n   * - `populateAllDefaults`: Legacy behavior - set default when there is a primitive value, an non-empty object field,\n   *        or the field itself is required  |\n   * - `populateRequiredDefaults`: Only sets default when a value is an object and its parent field is required, or it\n   *        is a primitive value and it is required |\n   * - `skipDefaults`: Does not set defaults                                                                                                      |\n   * - `skipEmptyDefaults`: Does not set an empty default. It will still apply the default value if a default property is defined in your schema.                                                                                                 |\n   */\n  emptyObjectFields?: 'populateAllDefaults' | 'populateRequiredDefaults' | 'skipDefaults' | 'skipEmptyDefaults';\n  /**\n   * Optional flag to compute the default form state using allOf and if/then/else schemas. Defaults to `skipDefaults'.\n   */\n  allOf?: 'populateDefaults' | 'skipDefaults';\n};\n\n/** The interface representing a Date object that contains an optional time */\nexport interface DateObject {\n  /** The year of the Date */\n  year: number;\n  /** The month of the Date */\n  month: number;\n  /** The day of the Date */\n  day: number;\n  /** The optional hours for the time of a Date */\n  hour?: number;\n  /** The optional minutes for the time of a Date */\n  minute?: number;\n  /** The optional seconds for the time of a Date */\n  second?: number;\n}\n\n/** Properties describing a Range specification in terms of attribute that can be added to the `HTML` `<input>` */\nexport type RangeSpecType = {\n  /** Specifies the interval between legal numbers in an input field */\n  step?: number;\n  /** Specifies a minimum value for an <input> element */\n  min?: number;\n  /** Specifies the maximum value for an <input> element */\n  max?: number;\n};\n\n/** Properties describing a Range specification in terms of attribute that can be added to the `HTML` `<input>` */\nexport type InputPropsType = Omit<RangeSpecType, 'step'> & {\n  /** Specifies the type of the <input> element */\n  type: string;\n  /** Specifies the interval between legal numbers in an input field or \"any\" */\n  step?: number | 'any';\n  /** Specifies the `autoComplete` value for an <input> element */\n  autoComplete?: HTMLInputElement['autocomplete'];\n};\n\n/** Type describing an id used for a field in the `IdSchema` */\nexport type FieldId = {\n  /** The id for a field */\n  $id: string;\n};\n\n/** Type describing a recursive structure of `FieldId`s for an object with a non-empty set of keys */\nexport type IdSchema<T = any> = T extends GenericObjectType\n  ? FieldId & {\n      /** The set of ids for fields in the recursive object structure */\n      [key in keyof T]?: IdSchema<T[key]>;\n    }\n  : FieldId;\n\n/** Type describing a name used for a field in the `PathSchema` */\nexport type FieldPath = {\n  /** The name of a field */\n  $name: string;\n};\n\n/** Type describing a recursive structure of `FieldPath`s for an object with a non-empty set of keys */\nexport type PathSchema<T = any> = T extends Array<infer U>\n  ? FieldPath & {\n      [i: number]: PathSchema<U>;\n    }\n  : T extends GenericObjectType\n  ? FieldPath & {\n      /** The set of names for fields in the recursive object structure */\n      [key in keyof T]?: PathSchema<T[key]>;\n    }\n  : FieldPath;\n\n/** The type for error produced by RJSF schema validation */\nexport type RJSFValidationError = {\n  /** Name of the error, for example, \"required\" or \"minLength\" */\n  name?: string;\n  /** Message, for example, \"is a required property\" or \"should NOT be shorter than 3 characters\" */\n  message?: string;\n  /** An object with the error params returned by ajv\n   * ([see doc](https://github.com/ajv-validator/ajv/tree/6a671057ea6aae690b5967ee26a0ddf8452c6297#error-parameters)\n   * for more info)\n   */\n  params?: any;\n  /** A string in Javascript property accessor notation to the data path of the field with the error. For example,\n   * `.name` or `['first-name']`\n   */\n  property?: string;\n  /** JSON pointer to the schema of the keyword that failed validation. For example, `#/fields/firstName/required`.\n   * (Note: this may sometimes be wrong due to a [bug in ajv](https://github.com/ajv-validator/ajv/issues/512))\n   */\n  schemaPath?: string;\n  /** Full error name, for example \".name is a required property\" */\n  stack: string;\n};\n\n/** The type that describes an error in a field */\nexport type FieldError = string;\n\n/** The type that describes the list of errors for a field */\nexport type FieldErrors = {\n  /** The list of errors for the field */\n  __errors?: FieldError[];\n};\n\n/** Type describing a recursive structure of `FieldErrors`s for an object with a non-empty set of keys */\nexport type ErrorSchema<T = any> = FieldErrors & {\n  /** The set of errors for fields in the recursive object structure */\n  [key in keyof T]?: ErrorSchema<T[key]>;\n};\n\n/** Type that describes the list of errors for a field being actively validated by a custom validator */\nexport type FieldValidation = FieldErrors & {\n  /** Function that will add a new `message` to the list of errors */\n  addError: (message: string) => void;\n};\n\n/** Type describing a recursive structure of `FieldValidation`s for an object with a non-empty set of keys */\nexport type FormValidation<T = any> = FieldValidation & {\n  /** The set of validation objects for fields in the recursive object structure */\n  [key in keyof T]?: FormValidation<T[key]>;\n};\n\n/** The properties that are passed to an `ErrorListTemplate` implementation */\nexport type ErrorListProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The errorSchema constructed by `Form` */\n  errorSchema: ErrorSchema<T>;\n  /** An array of the errors */\n  errors: RJSFValidationError[];\n  /** The `formContext` object that was passed to `Form` */\n  formContext?: F;\n  /** The schema that was passed to `Form` */\n  schema: S;\n  /** The uiSchema that was passed to `Form` */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to an `FieldErrorTemplate` implementation */\nexport type FieldErrorProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The errorSchema constructed by `Form` */\n  errorSchema?: ErrorSchema<T>;\n  /** An array of the errors */\n  errors?: Array<string | ReactElement>;\n  /** The tree of unique ids for every child field */\n  idSchema: IdSchema<T>;\n  /** The schema that was passed to field */\n  schema: S;\n  /** The uiSchema that was passed to field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to an `FieldHelpTemplate` implementation */\nexport type FieldHelpProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The help information to be rendered */\n  help?: string | ReactElement;\n  /** The tree of unique ids for every child field */\n  idSchema: IdSchema<T>;\n  /** The schema that was passed to field */\n  schema: S;\n  /** The uiSchema that was passed to field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** Flag indicating whether there are errors associated with this field */\n  hasErrors?: boolean;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The set of `Fields` stored in the `Registry` */\nexport type RegistryFieldsType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** A `Field` indexed by `name` */\n  [name: string]: Field<T, S, F>;\n};\n\n/** The set of `Widgets` stored in the `Registry` */\nexport type RegistryWidgetsType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** A `Widget` indexed by `name` */\n  [name: string]: Widget<T, S, F>;\n};\n\n/** The set of RJSF templates that can be overridden by themes or users */\nexport interface TemplatesType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** The template to use while rendering normal or fixed array fields */\n  ArrayFieldTemplate: ComponentType<ArrayFieldTemplateProps<T, S, F>>;\n  /** The template to use while rendering the description for an array field */\n  ArrayFieldDescriptionTemplate: ComponentType<ArrayFieldDescriptionProps<T, S, F>>;\n  /** The template to use while rendering an item in an array field */\n  ArrayFieldItemTemplate: ComponentType<ArrayFieldTemplateItemType<T, S, F>>;\n  /** The template to use while rendering the title for an array field */\n  ArrayFieldTitleTemplate: ComponentType<ArrayFieldTitleProps<T, S, F>>;\n  /** The template to use while rendering the standard html input */\n  BaseInputTemplate: ComponentType<BaseInputTemplateProps<T, S, F>>;\n  /** The template to use for rendering the description of a field */\n  DescriptionFieldTemplate: ComponentType<DescriptionFieldProps<T, S, F>>;\n  /** The template to use while rendering the errors for the whole form */\n  ErrorListTemplate: ComponentType<ErrorListProps<T, S, F>>;\n  /** The template to use while rendering the errors for a single field */\n  FieldErrorTemplate: ComponentType<FieldErrorProps<T, S, F>>;\n  /** The template to use while rendering the errors for a single field */\n  FieldHelpTemplate: ComponentType<FieldHelpProps<T, S, F>>;\n  /** The template to use while rendering a field */\n  FieldTemplate: ComponentType<FieldTemplateProps<T, S, F>>;\n  /** The template to use while rendering an object */\n  ObjectFieldTemplate: ComponentType<ObjectFieldTemplateProps<T, S, F>>;\n  /** The template to use for rendering the title of a field */\n  TitleFieldTemplate: ComponentType<TitleFieldProps<T, S, F>>;\n  /** The template to use for rendering information about an unsupported field type in the schema */\n  UnsupportedFieldTemplate: ComponentType<UnsupportedFieldProps<T, S, F>>;\n  /** The template to use for rendering a field that allows a user to add additional properties */\n  WrapIfAdditionalTemplate: ComponentType<WrapIfAdditionalTemplateProps<T, S, F>>;\n  /** The set of templates associated with buttons in the form */\n  ButtonTemplates: {\n    /** The template to use for the main `Submit` button  */\n    SubmitButton: ComponentType<SubmitButtonProps<T, S, F>>;\n    /** The template to use for the Add button used for AdditionalProperties and Array items */\n    AddButton: ComponentType<IconButtonProps<T, S, F>>;\n    /** The template to use for the Copy button used for Array items */\n    CopyButton: ComponentType<IconButtonProps<T, S, F>>;\n    /** The template to use for the Move Down button used for Array items */\n    MoveDownButton: ComponentType<IconButtonProps<T, S, F>>;\n    /** The template to use for the Move Up button used for Array items */\n    MoveUpButton: ComponentType<IconButtonProps<T, S, F>>;\n    /** The template to use for the Remove button used for AdditionalProperties and Array items */\n    RemoveButton: ComponentType<IconButtonProps<T, S, F>>;\n  };\n}\n\n/** The set of UiSchema options that can be set globally and used as fallbacks at an individual template, field or\n * widget level when no field-level value of the option is provided.\n */\nexport type GlobalUISchemaOptions = {\n  /** Flag, if set to `false`, new items cannot be added to array fields, unless overridden (defaults to true) */\n  addable?: boolean;\n  /** Flag, if set to `true`, array items can be copied (defaults to false) */\n  copyable?: boolean;\n  /** Flag, if set to `false`, array items cannot be ordered (defaults to true) */\n  orderable?: boolean;\n  /** Flag, if set to `false`, array items will not be removable (defaults to true) */\n  removable?: boolean;\n  /** Field labels are rendered by default. Labels may be omitted by setting the `label` option to `false` */\n  label?: boolean;\n  /** When using `additionalProperties`, key collision is prevented by appending a unique integer to the duplicate key.\n   * This option allows you to change the separator between the original key name and the integer. Default is \"-\"\n   */\n  duplicateKeySuffixSeparator?: string;\n};\n\n/** The object containing the registered core, theme and custom fields and widgets as well as the root schema, form\n * context, schema utils and templates.\n */\nexport interface Registry<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** The set of all fields used by the `Form`. Includes fields from `core`, theme-specific fields and any custom\n   * registered fields\n   */\n  fields: RegistryFieldsType<T, S, F>;\n  /** The set of templates used by the `Form`. Includes templates from `core`, theme-specific fields and any custom\n   * registered templates\n   */\n  templates: TemplatesType<T, S, F>;\n  /** The set of all widgets used by the `Form`. Includes widgets from `core`, theme-specific widgets and any custom\n   * registered widgets\n   */\n  widgets: RegistryWidgetsType<T, S, F>;\n  /** The `formContext` object that was passed to `Form` */\n  formContext: F;\n  /** The root schema, as passed to the `Form`, which can contain referenced definitions */\n  rootSchema: S;\n  /** The current implementation of the `SchemaUtilsType` (from `@rjsf/utils`) in use by the `Form`.  Used to call any\n   * of the validation-schema-based utility functions\n   */\n  schemaUtils: SchemaUtilsType<T, S>;\n  /** The string translation function to use when displaying any of the RJSF strings in templates, fields or widgets */\n  translateString: (stringKey: TranslatableString, params?: string[]) => string;\n  /** The optional global UI Options that are available for all templates, fields and widgets to access */\n  globalUiOptions?: GlobalUISchemaOptions;\n}\n\n/** The properties that are passed to a Field implementation */\nexport interface FieldProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  extends GenericObjectType,\n    Pick<HTMLAttributes<HTMLElement>, Exclude<keyof HTMLAttributes<HTMLElement>, 'onBlur' | 'onFocus' | 'onChange'>> {\n  /** The JSON subschema object for this field */\n  schema: S;\n  /** The uiSchema for this field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The tree of unique ids for every child field */\n  idSchema: IdSchema<T>;\n  /** The data for this field */\n  formData?: T;\n  /** The tree of errors for this field and its children */\n  errorSchema?: ErrorSchema<T>;\n  /** The field change event handler; called with the updated form data and an optional `ErrorSchema` */\n  onChange: (newFormData: T | undefined, es?: ErrorSchema<T>, id?: string) => any;\n  /** The input blur event handler; call it with the field id and value */\n  onBlur: (id: string, value: any) => void;\n  /** The input focus event handler; call it with the field id and value */\n  onFocus: (id: string, value: any) => void;\n  /** The `formContext` object that you passed to `Form` */\n  formContext?: F;\n  /** A boolean value stating if the field should autofocus */\n  autofocus?: boolean;\n  /** A boolean value stating if the field is disabled */\n  disabled?: boolean;\n  /** A boolean value stating if the field is hiding its errors */\n  hideError?: boolean;\n  /** A boolean value stating if the field is read-only */\n  readonly?: boolean;\n  /** The required status of this field */\n  required?: boolean;\n  /** The unique name of the field, usually derived from the name of the property in the JSONSchema */\n  name: string;\n  /** To avoid collisions with existing ids in the DOM, it is possible to change the prefix used for ids;\n   * Default is `root`\n   */\n  idPrefix?: string;\n  /** To avoid using a path separator that is present in field names, it is possible to change the separator used for\n   * ids (Default is `_`)\n   */\n  idSeparator?: string;\n  /** An array of strings listing all generated error messages from encountered errors for this field */\n  rawErrors?: string[];\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n}\n\n/** The definition of a React-based Field component */\nexport type Field<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = ComponentType<\n  FieldProps<T, S, F>\n>;\n\n/** The properties that are passed to a FieldTemplate implementation */\nexport type FieldTemplateProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The id of the field in the hierarchy. You can use it to render a label targeting the wrapped widget */\n  id: string;\n  /** A string containing the base CSS classes, merged with any custom ones defined in your uiSchema */\n  classNames?: string;\n  /** An object containing the style as defined in the `uiSchema` */\n  style?: StyleHTMLAttributes<any>;\n  /** The computed label for this field, as a string */\n  label: string;\n  /** A component instance rendering the field description, if one is defined (this will use any custom\n   * `DescriptionField` defined)\n   */\n  description?: ReactElement;\n  /** A string containing any `ui:description` uiSchema directive defined */\n  rawDescription?: string;\n  /** The field or widget component instance for this field row */\n  children: ReactElement;\n  /** A component instance listing any encountered errors for this field */\n  errors?: ReactElement;\n  /** An array of strings listing all generated error messages from encountered errors for this field */\n  rawErrors?: string[];\n  /** A component instance rendering any `ui:help` uiSchema directive defined */\n  help?: ReactElement;\n  /** A string containing any `ui:help` uiSchema directive defined. **NOTE:** `rawHelp` will be `undefined` if passed\n   * `ui:help` is a React component instead of a string\n   */\n  rawHelp?: string;\n  /** A boolean value stating if the field should be hidden */\n  hidden?: boolean;\n  /** A boolean value stating if the field is required */\n  required?: boolean;\n  /** A boolean value stating if the field is read-only */\n  readonly: boolean;\n  /** A boolean value stating if the field is hiding its errors */\n  hideError?: boolean;\n  /** A boolean value stating if the field is disabled */\n  disabled: boolean;\n  /** A boolean value stating if the label should be rendered or not. This is useful for nested fields in arrays where\n   * you don't want to clutter the UI\n   */\n  displayLabel?: boolean;\n  /** The schema object for this field */\n  schema: S;\n  /** The uiSchema object for this field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `formContext` object that was passed to `Form` */\n  formContext?: F;\n  /** The formData for this field */\n  formData?: T;\n  /** The value change event handler; Can be called with a new value to change the value for this field */\n  onChange: FieldProps<T, S, F>['onChange'];\n  /** The key change event handler; Called when the key associated with a field is changed for an additionalProperty */\n  onKeyChange: (value: string) => () => void;\n  /** The property drop/removal event handler; Called when a field is removed in an additionalProperty context */\n  onDropPropertyClick: (value: string) => () => void;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to the `UnsupportedFieldTemplate` implementation */\nexport type UnsupportedFieldProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The schema object for this field */\n  schema: S;\n  /** The tree of unique ids for every child field */\n  idSchema?: IdSchema<T>;\n  /** The reason why the schema field has an unsupported type */\n  reason: string;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to a `TitleFieldTemplate` implementation */\nexport type TitleFieldProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The id of the field title in the hierarchy */\n  id: string;\n  /** The title for the field being rendered */\n  title: string;\n  /** The schema object for the field being titled */\n  schema: S;\n  /** The uiSchema object for this title field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** A boolean value stating if the field is required */\n  required?: boolean;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to a `DescriptionFieldTemplate` implementation */\nexport type DescriptionFieldProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The id of the field description in the hierarchy */\n  id: string;\n  /** The schema object for the field being described */\n  schema: S;\n  /** The uiSchema object for this description field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The description of the field being rendered */\n  description: string | ReactElement;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to a `ArrayFieldTitleTemplate` implementation */\nexport type ArrayFieldTitleProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = Omit<TitleFieldProps<T, S, F>, 'id' | 'title'> & {\n  /** The title for the field being rendered */\n  title?: string;\n  /** The idSchema of the field in the hierarchy */\n  idSchema: IdSchema<T>;\n};\n\n/** The properties that are passed to a `ArrayFieldDescriptionTemplate` implementation */\nexport type ArrayFieldDescriptionProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = Omit<DescriptionFieldProps<T, S, F>, 'id' | 'description'> & {\n  /** The description of the field being rendered */\n  description?: string | ReactElement;\n  /** The idSchema of the field in the hierarchy */\n  idSchema: IdSchema<T>;\n};\n\n/** The properties of each element in the ArrayFieldTemplateProps.items array */\nexport type ArrayFieldTemplateItemType<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = {\n  /** The html for the item's content */\n  children: ReactElement;\n  /** The className string */\n  className: string;\n  /** A boolean value stating if the array item is disabled */\n  disabled?: boolean;\n  /** A boolean value stating whether new items can be added to the array */\n  canAdd: boolean;\n  /** A boolean value stating whether the array item can be copied, assumed false if missing */\n  hasCopy: boolean;\n  /** A boolean value stating whether the array item can be moved down */\n  hasMoveDown: boolean;\n  /** A boolean value stating whether the array item can be moved up */\n  hasMoveUp: boolean;\n  /** A boolean value stating whether the array item can be removed */\n  hasRemove: boolean;\n  /** A boolean value stating whether the array item has a toolbar */\n  hasToolbar: boolean;\n  /** A number stating the index the array item occurs in `items` */\n  index: number;\n  /** A number stating the total number `items` in the array */\n  totalItems: number;\n  /** Returns a function that adds a new item at `index` */\n  onAddIndexClick: (index: number) => (event?: any) => void;\n  /** Returns a function that copies the item at `index` into the position at `index + 1` */\n  onCopyIndexClick: (index: number) => (event?: any) => void;\n  /** Returns a function that removes the item at `index` */\n  onDropIndexClick: (index: number) => (event?: any) => void;\n  /** Returns a function that swaps the items at `index` with `newIndex` */\n  onReorderClick: (index: number, newIndex: number) => (event?: any) => void;\n  /** A boolean value stating if the array item is read-only */\n  readonly?: boolean;\n  /** A stable, unique key for the array item */\n  key: string;\n  /** The schema object for this array item */\n  schema: S;\n  /** The uiSchema object for this array item */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to an ArrayFieldTemplate implementation */\nexport type ArrayFieldTemplateProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = {\n  /** A boolean value stating whether new elements can be added to the array */\n  canAdd?: boolean;\n  /** The className string */\n  className?: string;\n  /** A boolean value stating if the array is disabled */\n  disabled?: boolean;\n  /** An object containing the id for this object & ids for its properties */\n  idSchema: IdSchema<T>;\n  /** An array of objects representing the items in the array */\n  items: ArrayFieldTemplateItemType<T, S, F>[];\n  /** A function that adds a new item to the array */\n  onAddClick: (event?: any) => void;\n  /** A boolean value stating if the array is read-only */\n  readonly?: boolean;\n  /** A boolean value stating if the array is required */\n  required?: boolean;\n  /** A boolean value stating if the field is hiding its errors */\n  hideError?: boolean;\n  /** The schema object for this array */\n  schema: S;\n  /** The uiSchema object for this array field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** A string value containing the title for the array */\n  title: string;\n  /** The `formContext` object that was passed to Form */\n  formContext?: F;\n  /** The formData for this array */\n  formData?: T;\n  /** The tree of errors for this field and its children */\n  errorSchema?: ErrorSchema<T>;\n  /** An array of strings listing all generated error messages from encountered errors for this widget */\n  rawErrors?: string[];\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties of each element in the ObjectFieldTemplateProps.properties array */\nexport type ObjectFieldTemplatePropertyType = {\n  /** The html for the property's content */\n  content: ReactElement;\n  /** A string representing the property name */\n  name: string;\n  /** A boolean value stating if the object property is disabled */\n  disabled?: boolean;\n  /** A boolean value stating if the property is read-only */\n  readonly?: boolean;\n  /** A boolean value stating if the property should be hidden */\n  hidden: boolean;\n};\n\n/** The properties that are passed to an ObjectFieldTemplate implementation */\nexport type ObjectFieldTemplateProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = {\n  /** A string value containing the title for the object */\n  title: string;\n  /** A string value containing the description for the object */\n  description?: string;\n  /** A boolean value stating if the object is disabled */\n  disabled?: boolean;\n  /** An array of objects representing the properties in the object */\n  properties: ObjectFieldTemplatePropertyType[];\n  /** Returns a function that adds a new property to the object (to be used with additionalProperties) */\n  onAddClick: (schema: S) => () => void;\n  /** A boolean value stating if the object is read-only */\n  readonly?: boolean;\n  /** A boolean value stating if the object is required */\n  required?: boolean;\n  /** A boolean value stating if the field is hiding its errors */\n  hideError?: boolean;\n  /** The schema object for this object */\n  schema: S;\n  /** The uiSchema object for this object field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** An object containing the id for this object & ids for its properties */\n  idSchema: IdSchema<T>;\n  /** The optional validation errors in the form of an `ErrorSchema` */\n  errorSchema?: ErrorSchema<T>;\n  /** The form data for the object */\n  formData?: T;\n  /** The `formContext` object that was passed to Form */\n  formContext?: F;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to a WrapIfAdditionalTemplate implementation */\nexport type WrapIfAdditionalTemplateProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = {\n  /** The field or widget component instance for this field row */\n  children: ReactNode;\n} & Pick<\n  FieldTemplateProps<T, S, F>,\n  | 'id'\n  | 'classNames'\n  | 'style'\n  | 'label'\n  | 'required'\n  | 'readonly'\n  | 'disabled'\n  | 'schema'\n  | 'uiSchema'\n  | 'onKeyChange'\n  | 'onDropPropertyClick'\n  | 'registry'\n>;\n\n/** The properties that are passed to a Widget implementation */\nexport interface WidgetProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  extends GenericObjectType,\n    Pick<HTMLAttributes<HTMLElement>, Exclude<keyof HTMLAttributes<HTMLElement>, 'onBlur' | 'onFocus'>> {\n  /** The generated id for this widget, used to provide unique `name`s and `id`s for the HTML field elements rendered by\n   * widgets\n   */\n  id: string;\n  /** The unique name of the field, usually derived from the name of the property in the JSONSchema; Provided in support\n   * of custom widgets.\n   */\n  name: string;\n  /** The JSONSchema subschema object for this widget */\n  schema: S;\n  /** The uiSchema for this widget */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The current value for this widget */\n  value: any;\n  /** The required status of this widget */\n  required?: boolean;\n  /** A boolean value stating if the widget is disabled */\n  disabled?: boolean;\n  /** A boolean value stating if the widget is read-only */\n  readonly?: boolean;\n  /** A boolean value stating if the widget is hiding its errors */\n  hideError?: boolean;\n  /** A boolean value stating if the widget should autofocus */\n  autofocus?: boolean;\n  /** The placeholder for the widget, if any */\n  placeholder?: string;\n  /** A map of UI Options passed as a prop to the component, including the optional `enumOptions`\n   * which is a special case on top of `UIOptionsType` needed only by widgets\n   */\n  options: NonNullable<UIOptionsType<T, S, F>> & {\n    /** The enum options list for a type that supports them */\n    enumOptions?: EnumOptionsType<S>[];\n  };\n  /** The `formContext` object that you passed to `Form` */\n  formContext?: F;\n  /** The input blur event handler; call it with the widget id and value */\n  onBlur: (id: string, value: any) => void;\n  /** The value change event handler; call it with the new value every time it changes */\n  onChange: (value: any, es?: ErrorSchema<T>, id?: string) => void;\n  /** The input focus event handler; call it with the widget id and value */\n  onFocus: (id: string, value: any) => void;\n  /** The computed label for this widget, as a string */\n  label: string;\n  /** A boolean value, if true, will cause the label to be hidden. This is useful for nested fields where you don't want\n   * to clutter the UI. Customized via `label` in the `UiSchema`\n   */\n  hideLabel?: boolean;\n  /** A boolean value stating if the widget can accept multiple values */\n  multiple?: boolean;\n  /** An array of strings listing all generated error messages from encountered errors for this widget */\n  rawErrors?: string[];\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n}\n\n/** The definition of a React-based Widget component */\nexport type Widget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = ComponentType<\n  WidgetProps<T, S, F>\n>;\n\n/** The properties that are passed to the BaseInputTemplate */\nexport interface BaseInputTemplateProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> extends WidgetProps<T, S, F> {\n  /** A `BaseInputTemplate` implements a default `onChange` handler that it passes to the HTML input component to handle\n   * the `ChangeEvent`. Sometimes a widget may need to handle the `ChangeEvent` using custom logic. If that is the case,\n   * that widget should provide its own handler via this prop.\n   */\n  onChangeOverride?: (event: ChangeEvent<HTMLInputElement>) => void;\n}\n\n/** The type that defines the props used by the Submit button */\nexport type SubmitButtonProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The uiSchema for this widget */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The type that defines the props for an Icon button, extending from a basic HTML button attributes */\nexport type IconButtonProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = ButtonHTMLAttributes<HTMLButtonElement> & {\n  /** An alternative specification for the type of the icon button */\n  iconType?: string;\n  /** The name representation or actual react element implementation for the icon */\n  icon?: string | ReactElement;\n  /** The uiSchema for this widget */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The type that defines how to change the behavior of the submit button for the form */\nexport type UISchemaSubmitButtonOptions = {\n  /** The text of the submit button. Set to \"Submit\" by default */\n  submitText?: string;\n  /** Flag, if `true`, removes the submit button completely from the form */\n  norender?: boolean;\n  /** Any other props to be passed to the submit button itself */\n  props?: GenericObjectType & {\n    /** A boolean value stating if the submit button is disabled */\n    disabled?: boolean;\n    /** The class name for the submit button */\n    className?: string;\n  };\n};\n\n/** This type represents an element used to render an enum option */\nexport type EnumOptionsType<S extends StrictRJSFSchema = RJSFSchema> = {\n  /** The value for the enum option */\n  value: any;\n  /** The label for the enum options */\n  label: string;\n  /** The schema associated with the enum option when the option represents a `oneOf` or `anyOf` choice */\n  schema?: S;\n};\n\n/** This type remaps the keys of `Type` to prepend `ui:` onto them. As a result it does not need to be exported */\ntype MakeUIType<Type> = {\n  [Property in keyof Type as `ui:${string & Property}`]: Type[Property];\n};\n\n/** This type represents all the known supported options in the `ui:options` property, kept separate in order to\n * remap the keys. It also contains all the properties, optionally, of `TemplatesType` except \"ButtonTemplates\"\n */\ntype UIOptionsBaseType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = Partial<\n  Omit<TemplatesType<T, S, F>, 'ButtonTemplates'>\n> &\n  GlobalUISchemaOptions & {\n    /** Any classnames that the user wants to be applied to a field in the ui */\n    classNames?: string;\n    /** Any custom style that the user wants to apply to a field in the ui, applied on the same element as classNames */\n    style?: StyleHTMLAttributes<any>;\n    /** We know that for title, it will be a string, if it is provided */\n    title?: string;\n    /** We know that for description, it will be a string, if it is provided */\n    description?: string;\n    /** We know that for placeholder, it will be a string, if it is provided */\n    placeholder?: string;\n    /** Used to add text next to a field to guide the end user in filling it in */\n    help?: string;\n    /** Flag, if set to `true`, will mark the field as automatically focused on a text input or textarea input */\n    autofocus?: boolean;\n    /** Use to mark the field as supporting auto complete on a text input or textarea input */\n    autocomplete?: HTMLInputElement['autocomplete'];\n    /** Flag, if set to `true`, will mark all child widgets from a given field as disabled */\n    disabled?: boolean;\n    /** The default value to use when an input for a field is empty */\n    emptyValue?: any;\n    /** Will disable any of the enum options specified in the array (by value) */\n    enumDisabled?: Array<string | number | boolean>;\n    /** Flag, if set to `true`, will hide the default error display for the given field AND all of its child fields in the\n     * hierarchy\n     */\n    hideError?: boolean;\n    /** Flag, if set to `true`, will mark all child widgets from a given field as read-only */\n    readonly?: boolean;\n    /** This property allows you to reorder the properties that are shown for a particular object */\n    order?: string[];\n    /** Flag, if set to `true`, will cause the `FileWidget` to show a preview (with download for non-image files) */\n    filePreview?: boolean;\n    /** Flag, if set to `true`, will mark a list of checkboxes as displayed all on one line instead of one per row */\n    inline?: boolean;\n    /** Used to change the input type (for example, `tel` or `email`) for an <input> */\n    inputType?: string;\n    /** Provides a means to set the initial height of a textarea widget */\n    rows?: number;\n    /** If submitButtonOptions is provided it should match the `UISchemaSubmitButtonOptions` type */\n    submitButtonOptions?: UISchemaSubmitButtonOptions;\n    /** Allows RJSF to override the default widget implementation by specifying either the name of a widget that is used\n     * to look up an implementation from the `widgets` list or an actual one-off widget implementation itself\n     */\n    widget?: Widget<T, S, F> | string;\n    /** Allows a user to provide a list of labels for enum values in the schema */\n    enumNames?: string[];\n  };\n\n/** The type that represents the Options potentially provided by `ui:options` */\nexport type UIOptionsType<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = UIOptionsBaseType<T, S, F> & {\n  /** Anything else will be one of these types */\n  [key: string]: boolean | number | string | object | any[] | null | undefined;\n};\n\n/** Type describing the well-known properties of the `UiSchema` while also supporting all user defined properties,\n * starting with `ui:`.\n */\nexport type UiSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = GenericObjectType &\n  MakeUIType<UIOptionsBaseType<T, S, F>> & {\n    /** The set of Globally relevant UI Schema options that are read from the root-level UiSchema and stored in the\n     * Registry for use everywhere.\n     */\n    'ui:globalOptions'?: GlobalUISchemaOptions;\n    /** Allows the form to generate a unique prefix for the `Form`'s root prefix  */\n    'ui:rootFieldId'?: string;\n    /** Allows RJSF to override the default field implementation by specifying either the name of a field that is used\n     * to look up an implementation from the `fields` list or an actual one-off `Field` component implementation itself\n     */\n    'ui:field'?: Field<T, S, F> | string;\n    /** By default, any field that is rendered for an `anyOf`/`oneOf` schema will be wrapped inside the `AnyOfField` or\n     * `OneOfField` component. This default behavior may be undesirable if your custom field already handles behavior\n     * related to choosing one or more subschemas contained in the `anyOf`/`oneOf` schema.\n     * By providing a `true` value for this flag in association with a custom `ui:field`, the wrapped components will be\n     * omitted, so just one instance of the custom field will be rendered. If the flag is omitted or set to `false`,\n     * your custom field will be wrapped by `AnyOfField`/`OneOfField`.\n     */\n    'ui:fieldReplacesAnyOrOneOf'?: boolean;\n    /** An object that contains all the potential UI options in a single object */\n    'ui:options'?: UIOptionsType<T, S, F>;\n  };\n\n/** A `CustomValidator` function takes in a `formData`, `errors` and `uiSchema` objects and returns the given `errors`\n * object back, while potentially adding additional messages to the `errors`\n */\nexport type CustomValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = (\n  formData: T | undefined,\n  errors: FormValidation<T>,\n  uiSchema?: UiSchema<T, S, F>\n) => FormValidation<T>;\n\n/** An `ErrorTransformer` function will take in a list of `errors` & a `uiSchema` and potentially return a\n * transformation of those errors in what ever way it deems necessary\n */\nexport type ErrorTransformer<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = (\n  errors: RJSFValidationError[],\n  uiSchema?: UiSchema<T, S, F>\n) => RJSFValidationError[];\n\n/** The type that describes the data that is returned from the `ValidatorType.validateFormData()` function */\nexport type ValidationData<T> = {\n  /** The validation errors as a list of `RJSFValidationError` objects */\n  errors: RJSFValidationError[];\n  /** The validation errors in the form of an `ErrorSchema` */\n  errorSchema: ErrorSchema<T>;\n};\n\n/** The interface that describes the validation functions that are provided by a Validator implementation used by the\n * schema utilities.\n */\nexport interface ValidatorType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T>;\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath?: string[]): RJSFValidationError[];\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S): boolean;\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   */\n  rawValidation<Result = any>(schema: S, formData?: T): { errors?: Result[]; validationError?: Error };\n  /** An optional function that can be used to reset validator implementation. Useful for clear schemas in the AJV\n   * instance for tests.\n   */\n  reset?: () => void;\n}\n\n/** The `SchemaUtilsType` interface provides a wrapper around the publicly exported APIs in the `@rjsf/utils/schema`\n * directory such that one does not have to explicitly pass the `validator` or `rootSchema` to each method. Since both\n * the `validator` and `rootSchema` generally does not change across a `Form`, this allows for providing a simplified\n * set of APIs to the `@rjsf/core` components and the various themes as well.\n */\nexport interface SchemaUtilsType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator(): ValidatorType<T, S, F>;\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] - Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n  ): boolean;\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n   *          false when computing defaults for any nested object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues?: boolean | 'excludeObjectChildren'\n  ): T | T[] | undefined;\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions): boolean;\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(\n    formData: T | undefined,\n    options: S[],\n    selectedOption?: number,\n    discriminatorField?: string\n  ): number;\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number;\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number;\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>): boolean;\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S): boolean;\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S): boolean;\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n   * `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T>;\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [formData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, formData?: T): S;\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schema that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all of the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T;\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string, formData?: T, idPrefix?: string, idSeparator?: string): IdSchema<T>;\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T>;\n}\n","import isPlainObject from 'lodash/isPlainObject';\n\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\n\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\n *\n * @param errorHandler - The `FormValidation` error handling structure\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\n */\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\n  return Object.keys(errorHandler).reduce((acc, key) => {\n    if (key === 'addError') {\n      return acc;\n    } else {\n      const childSchema = (errorHandler as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        return {\n          ...acc,\n          [key]: unwrapErrorHandler(childSchema),\n        };\n      }\n      return { ...acc, [key]: childSchema };\n    }\n  }, {} as ErrorSchema<T>);\n}\n","import pad from './pad';\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return '';\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n","import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from './mergeObjects';\nimport toErrorList from './toErrorList';\nimport { ErrorSchema, ValidationData } from './types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function validationDataMerge<T = any>(\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n","import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\nimport isObject from 'lodash/isObject';\n\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\n  for (const key in node) {\n    const realObj: { [k: string]: any } = node;\n    const value = realObj[key];\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\n    } else {\n      realObj[key] = withIdRefPrefix<S>(value);\n    }\n  }\n  return node;\n}\n\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\n  for (let i = 0; i < node.length; i++) {\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\n  }\n  return node;\n}\n\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\n * This is used in isValid to make references to the rootSchema\n *\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n * @returns - A copy of the `schemaNode` with updated `$ref`s\n */\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(\n  schemaNode: S | S[] | S[keyof S]\n): S | S[] | S[keyof S] {\n  if (Array.isArray(schemaNode)) {\n    return withIdRefPrefixArray<S>([...schemaNode]);\n  }\n  if (isObject(schemaNode)) {\n    return withIdRefPrefixObject<S>({ ...schemaNode });\n  }\n  return schemaNode;\n}\n","/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_SERVER_CONTEXT_TYPE:\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar SuspenseList = REACT_SUSPENSE_LIST_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false;\nvar hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isConcurrentMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\nfunction isSuspenseList(object) {\n  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n}\n\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.SuspenseList = SuspenseList;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isSuspenseList = isSuspenseList;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n","'use strict';\n\n// MODULES //\n\nvar isArray = require( 'validate.io-array' ),\n\tisIntegerArray = require( 'validate.io-integer-array' ),\n\tisFunction = require( 'validate.io-function' );\n\n\n// VARIABLES //\n\nvar MAXINT = Math.pow( 2, 31 ) - 1;\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: gcd( a, b )\n*\tComputes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm.\n*\n* @param {Number} a - integer\n* @param {Number} b - integer\n* @returns {Number} greatest common divisor\n*/\nfunction gcd( a, b ) {\n\tvar k = 1,\n\t\tt;\n\t// Simple cases:\n\tif ( a === 0 ) {\n\t\treturn b;\n\t}\n\tif ( b === 0 ) {\n\t\treturn a;\n\t}\n\t// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...\n\twhile ( a%2 === 0 && b%2 === 0 ) {\n\t\ta = a / 2; // right shift\n\t\tb = b / 2; // right shift\n\t\tk = k * 2; // left shift\n\t}\n\t// Reduce `a` to an odd number...\n\twhile ( a%2 === 0 ) {\n\t\ta = a / 2; // right shift\n\t}\n\t// Henceforth, `a` is always odd...\n\twhile ( b ) {\n\t\t// Remove all factors of 2 in `b`, as they are not common...\n\t\twhile ( b%2 === 0 ) {\n\t\t\tb = b / 2; // right shift\n\t\t}\n\t\t// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...\n\t\tif ( a > b ) {\n\t\t\tt = b;\n\t\t\tb = a;\n\t\t\ta = t;\n\t\t}\n\t\tb = b - a; // b=0 iff b=a\n\t}\n\t// Restore common factors of 2...\n\treturn k * a;\n} // end FUNCTION gcd()\n\n/**\n* FUNCTION: bitwise( a, b )\n*\tComputes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm and bitwise operations.\n*\n* @param {Number} a - safe integer\n* @param {Number} b - safe integer\n* @returns {Number} greatest common divisor\n*/\nfunction bitwise( a, b ) {\n\tvar k = 0,\n\t\tt;\n\t// Simple cases:\n\tif ( a === 0 ) {\n\t\treturn b;\n\t}\n\tif ( b === 0 ) {\n\t\treturn a;\n\t}\n\t// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...\n\twhile ( (a & 1) === 0 && (b & 1) === 0 ) {\n\t\ta >>>= 1; // right shift\n\t\tb >>>= 1; // right shift\n\t\tk++;\n\t}\n\t// Reduce `a` to an odd number...\n\twhile ( (a & 1) === 0 ) {\n\t\ta >>>= 1; // right shift\n\t}\n\t// Henceforth, `a` is always odd...\n\twhile ( b ) {\n\t\t// Remove all factors of 2 in `b`, as they are not common...\n\t\twhile ( (b & 1) === 0 ) {\n\t\t\tb >>>= 1; // right shift\n\t\t}\n\t\t// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...\n\t\tif ( a > b ) {\n\t\t\tt = b;\n\t\t\tb = a;\n\t\t\ta = t;\n\t\t}\n\t\tb = b - a; // b=0 iff b=a\n\t}\n\t// Restore common factors of 2...\n\treturn a << k;\n} // end FUNCTION bitwise()\n\n\n// GREATEST COMMON DIVISOR //\n\n/**\n* FUNCTION: compute( arr[, clbk] )\n*\tComputes the greatest common divisor.\n*\n* @param {Number[]|Number} arr - input array of integers\n* @param {Function|Number} [clbk] - accessor function for accessing array values\n* @returns {Number|Null} greatest common divisor or null\n*/\nfunction compute() {\n\tvar nargs = arguments.length,\n\t\targs,\n\t\tclbk,\n\t\tarr,\n\t\tlen,\n\t\ta, b,\n\t\ti;\n\n\t// Copy the input arguments to an array...\n\targs = new Array( nargs );\n\tfor ( i = 0; i < nargs; i++ ) {\n\t\targs[ i ] = arguments[ i ];\n\t}\n\t// Have we been provided with integer arguments?\n\tif ( isIntegerArray( args ) ) {\n\t\tif ( nargs === 2 ) {\n\t\t\ta = args[ 0 ];\n\t\t\tb = args[ 1 ];\n\t\t\tif ( a < 0 ) {\n\t\t\t\ta = -a;\n\t\t\t}\n\t\t\tif ( b < 0 ) {\n\t\t\t\tb = -b;\n\t\t\t}\n\t\t\tif ( a <= MAXINT && b <= MAXINT ) {\n\t\t\t\treturn bitwise( a, b );\n\t\t\t} else {\n\t\t\t\treturn gcd( a, b );\n\t\t\t}\n\t\t}\n\t\tarr = args;\n\t}\n\t// If not integers, ensure the first argument is an array...\n\telse if ( !isArray( args[ 0 ] ) ) {\n\t\tthrow new TypeError( 'gcd()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );\n\t}\n\t// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...\n\telse if ( nargs > 1 ) {\n\t\tarr = args[ 0 ];\n\t\tclbk = args[ 1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( 'gcd()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );\n\t\t}\n\t}\n\t// We have been provided an array...\n\telse {\n\t\tarr = args[ 0 ];\n\t}\n\tlen = arr.length;\n\n\t// Check if a sufficient number of values have been provided...\n\tif ( len < 2 ) {\n\t\treturn null;\n\t}\n\t// If an accessor is provided, extract the array values...\n\tif ( clbk ) {\n\t\ta = new Array( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\ta[ i ] = clbk( arr[ i ], i );\n\t\t}\n\t\tarr = a;\n\t}\n\t// Given an input array, ensure all array values are integers...\n\tif ( nargs < 3 ) {\n\t\tif ( !isIntegerArray( arr ) ) {\n\t\t\tthrow new TypeError( 'gcd()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );\n\t\t}\n\t}\n\t// Convert any negative integers to positive integers...\n\tfor ( i = 0; i < len; i++ ) {\n\t\ta = arr[ i ];\n\t\tif ( a < 0 ) {\n\t\t\tarr[ i ] = -a;\n\t\t}\n\t}\n\t// Exploit the fact that the gcd is an associative function...\n\ta = arr[ 0 ];\n\tfor ( i = 1; i < len; i++ ) {\n\t\tb = arr[ i ];\n\t\tif ( b <= MAXINT && a <= MAXINT ) {\n\t\t\ta = bitwise( a, b );\n\t\t} else {\n\t\t\ta = gcd( a, b );\n\t\t}\n\t}\n\treturn a;\n} // end FUNCTION compute()\n\n\n// EXPORTS //\n\nmodule.exports = compute;\n","'use strict';\n\n// MODULES //\n\nvar gcd = require( 'compute-gcd' ),\n\tisArray = require( 'validate.io-array' ),\n\tisIntegerArray = require( 'validate.io-integer-array' ),\n\tisFunction = require( 'validate.io-function' );\n\n\n// LEAST COMMON MULTIPLE //\n\n/**\n* FUNCTION: lcm( arr[, clbk] )\n*\tComputes the least common multiple (lcm).\n*\n* @param {Number[]|Number} arr - input array of integers\n* @param {Function|Number} [accessor] - accessor function for accessing array values\n* @returns {Number|Null} least common multiple or null\n*/\nfunction lcm() {\n\tvar nargs = arguments.length,\n\t\targs,\n\t\tclbk,\n\t\tarr,\n\t\tlen,\n\t\ta, b,\n\t\ti;\n\n\t// Copy the input arguments to an array...\n\targs = new Array( nargs );\n\tfor ( i = 0; i < nargs; i++ ) {\n\t\targs[ i ] = arguments[ i ];\n\t}\n\t// Have we been provided with integer arguments?\n\tif ( isIntegerArray( args ) ) {\n\t\tif ( nargs === 2 ) {\n\t\t\ta = args[ 0 ];\n\t\t\tb = args[ 1 ];\n\t\t\tif ( a < 0 ) {\n\t\t\t\ta = -a;\n\t\t\t}\n\t\t\tif ( b < 0 ) {\n\t\t\t\tb = -b;\n\t\t\t}\n\t\t\tif ( a === 0 || b === 0 ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn ( a/gcd(a,b) ) * b;\n\t\t}\n\t\tarr = args;\n\t}\n\t// If not integers, ensure that the first argument is an array...\n\telse if ( !isArray( args[ 0 ] ) ) {\n\t\tthrow new TypeError( 'lcm()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );\n\t}\n\t// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...\n\telse if ( nargs > 1 ) {\n\t\tarr = args[ 0 ];\n\t\tclbk = args[ 1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( 'lcm()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );\n\t\t}\n\t}\n\t// We have been provided an array...\n\telse {\n\t\tarr = args[ 0 ];\n\t}\n\tlen = arr.length;\n\n\t// Check if a sufficient number of values have been provided...\n\tif ( len < 2 ) {\n\t\treturn null;\n\t}\n\t// If an accessor is provided, extract the array values...\n\tif ( clbk ) {\n\t\ta = new Array( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\ta[ i ] = clbk( arr[ i ], i );\n\t\t}\n\t\tarr = a;\n\t}\n\t// Given an input array, ensure all array values are integers...\n\tif ( nargs < 3 ) {\n\t\tif ( !isIntegerArray( arr ) ) {\n\t\t\tthrow new TypeError( 'lcm()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );\n\t\t}\n\t}\n\t// Convert any negative integers to positive integers...\n\tfor ( i = 0; i < len; i++ ) {\n\t\ta = arr[ i ];\n\t\tif ( a < 0 ) {\n\t\t\tarr[ i ] = -a;\n\t\t}\n\t}\n\t// Exploit the fact that the lcm is an associative function...\n\ta = arr[ 0 ];\n\tfor ( i = 1; i < len; i++ ) {\n\t\tb = arr[ i ];\n\t\tif ( a === 0 || b === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\t\ta = ( a/gcd(a,b) ) * b;\n\t}\n\treturn a;\n} // end FUNCTION lcm()\n\n\n// EXPORTS //\n\nmodule.exports = lcm;\n","var isEqual = require('lodash/isEqual')\nvar sortBy = require('lodash/sortBy')\nvar uniq = require('lodash/uniq')\nvar uniqWith = require('lodash/uniqWith')\nvar defaults = require('lodash/defaults')\nvar intersectionWith = require('lodash/intersectionWith')\nvar isPlainObject = require('lodash/isPlainObject')\nvar isBoolean = require('lodash/isBoolean')\n\nvar normalizeArray = val => Array.isArray(val)\n  ? val : [val]\nvar undef = val => val === undefined\nvar keys = obj => isPlainObject(obj) || Array.isArray(obj) ? Object.keys(obj) : []\nvar has = (obj, key) => obj.hasOwnProperty(key)\nvar stringArray = arr => sortBy(uniq(arr))\nvar undefEmpty = val => undef(val) || (Array.isArray(val) && val.length === 0)\nvar keyValEqual = (a, b, key, compare) => b && has(b, key) && a && has(a, key) && compare(a[key], b[key])\nvar undefAndZero = (a, b) => (undef(a) && b === 0) || (undef(b) && a === 0) || isEqual(a, b)\nvar falseUndefined = (a, b) => (undef(a) && b === false) || (undef(b) && a === false) || isEqual(a, b)\nvar emptySchema = schema => undef(schema) || isEqual(schema, {}) || schema === true\nvar emptyObjUndef = schema => undef(schema) || isEqual(schema, {})\nvar isSchema = val => undef(val) || isPlainObject(val) || val === true || val === false\n\nfunction undefArrayEqual(a, b) {\n  if (undefEmpty(a) && undefEmpty(b)) {\n    return true\n  } else {\n    return isEqual(stringArray(a), stringArray(b))\n  }\n}\n\nfunction unsortedNormalizedArray(a, b) {\n  a = normalizeArray(a)\n  b = normalizeArray(b)\n  return isEqual(stringArray(a), stringArray(b))\n}\n\nfunction schemaGroup(a, b, key, compare) {\n  var allProps = uniq(keys(a).concat(keys(b)))\n  if (emptyObjUndef(a) && emptyObjUndef(b)) {\n    return true\n  } else if (emptyObjUndef(a) && keys(b).length) {\n    return false\n  } else if (emptyObjUndef(b) && keys(a).length) {\n    return false\n  }\n\n  return allProps.every(function(key) {\n    var aVal = a[key]\n    var bVal = b[key]\n    if (Array.isArray(aVal) && Array.isArray(bVal)) {\n      return isEqual(stringArray(a), stringArray(b))\n    } else if (Array.isArray(aVal) && !Array.isArray(bVal)) {\n      return false\n    } else if (Array.isArray(bVal) && !Array.isArray(aVal)) {\n      return false\n    }\n    return keyValEqual(a, b, key, compare)\n  })\n}\n\nfunction items(a, b, key, compare) {\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return compare(a, b)\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    return schemaGroup(a, b, key, compare)\n  } else {\n    return isEqual(a, b)\n  }\n}\n\nfunction unsortedArray(a, b, key, compare) {\n  var uniqueA = uniqWith(a, compare)\n  var uniqueB = uniqWith(b, compare)\n  var inter = intersectionWith(uniqueA, uniqueB, compare)\n  return inter.length === Math.max(uniqueA.length, uniqueB.length)\n}\n\nvar comparers = {\n  title: isEqual,\n  uniqueItems: falseUndefined,\n  minLength: undefAndZero,\n  minItems: undefAndZero,\n  minProperties: undefAndZero,\n  required: undefArrayEqual,\n  enum: undefArrayEqual,\n  type: unsortedNormalizedArray,\n  items: items,\n  anyOf: unsortedArray,\n  allOf: unsortedArray,\n  oneOf: unsortedArray,\n  properties: schemaGroup,\n  patternProperties: schemaGroup,\n  dependencies: schemaGroup\n}\n\nvar acceptsUndefined = [\n  'properties',\n  'patternProperties',\n  'dependencies',\n  'uniqueItems',\n  'minLength',\n  'minItems',\n  'minProperties',\n  'required'\n]\n\nvar schemaProps = ['additionalProperties', 'additionalItems', 'contains', 'propertyNames', 'not']\n\nfunction compare(a, b, options) {\n  options = defaults(options, {\n    ignore: []\n  })\n\n  if (emptySchema(a) && emptySchema(b)) {\n    return true\n  }\n\n  if (!isSchema(a) || !isSchema(b)) {\n    throw new Error('Either of the values are not a JSON schema.')\n  }\n  if (a === b) {\n    return true\n  }\n\n  if (isBoolean(a) && isBoolean(b)) {\n    return a === b\n  }\n\n  if ((a === undefined && b === false) || (b === undefined && a === false)) {\n    return false\n  }\n\n  if ((undef(a) && !undef(b)) || (!undef(a) && undef(b))) {\n    return false\n  }\n\n  var allKeys = uniq(Object.keys(a).concat(Object.keys(b)))\n\n  if (options.ignore.length) {\n    allKeys = allKeys.filter(k => options.ignore.indexOf(k) === -1)\n  }\n\n  if (!allKeys.length) {\n    return true\n  }\n\n  function innerCompare(a, b) {\n    return compare(a, b, options)\n  }\n\n  return allKeys.every(function(key) {\n    var aValue = a[key]\n    var bValue = b[key]\n\n    if (schemaProps.indexOf(key) !== -1) {\n      return compare(aValue, bValue, options)\n    }\n\n    var comparer = comparers[key]\n    if (!comparer) {\n      comparer = isEqual\n    }\n\n    // do simple lodash check first\n    if (isEqual(aValue, bValue)) {\n      return true\n    }\n\n    if (acceptsUndefined.indexOf(key) === -1) {\n      if ((!has(a, key) && has(b, key)) || (has(a, key) && !has(b, key))) {\n        return aValue === bValue\n      }\n    }\n\n    var result = comparer(aValue, bValue, key, innerCompare)\n    if (!isBoolean(result)) {\n      throw new Error('Comparer must return true or false')\n    }\n    return result\n  })\n}\n\nmodule.exports = compare\n","const flatten = require('lodash/flatten')\nconst flattenDeep = require('lodash/flattenDeep')\nconst isPlainObject = require('lodash/isPlainObject')\nconst uniq = require('lodash/uniq')\nconst uniqWith = require('lodash/uniqWith')\nconst without = require('lodash/without')\n\nfunction deleteUndefinedProps(returnObject) {\n  // cleanup empty\n  for (const prop in returnObject) {\n    if (has(returnObject, prop) && isEmptySchema(returnObject[prop])) {\n      delete returnObject[prop]\n    }\n  }\n  return returnObject\n}\n\nconst allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)))\nconst getValues = (schemas, key) => schemas.map(schema => schema && schema[key])\nconst has = (obj, propName) => Object.prototype.hasOwnProperty.call(obj, propName)\nconst keys = obj => {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj)\n  } else {\n    return []\n  }\n}\n\nconst notUndefined = (val) => val !== undefined\nconst isSchema = (val) => isPlainObject(val) || val === true || val === false\nconst isEmptySchema = (obj) => (!keys(obj).length) && obj !== false && obj !== true\nconst withoutArr = (arr, ...rest) => without.apply(null, [arr].concat(flatten(rest)))\n\nmodule.exports = {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  getValues,\n  has,\n  isEmptySchema,\n  isSchema,\n  keys,\n  notUndefined,\n  uniqWith,\n  withoutArr\n}\n","\nconst compare = require('json-schema-compare')\nconst forEach = require('lodash/forEach')\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  has,\n  isSchema,\n  notUndefined,\n  uniqWith\n} = require('../common')\n\nfunction removeFalseSchemasFromArray(target) {\n  forEach(target, function(schema, index) {\n    if (schema === false) {\n      target.splice(index, 1)\n    }\n  })\n}\n\nfunction getItemSchemas(subSchemas, key) {\n  return subSchemas.map(function(sub) {\n    if (!sub) {\n      return undefined\n    }\n\n    if (Array.isArray(sub.items)) {\n      const schemaAtPos = sub.items[key]\n      if (isSchema(schemaAtPos)) {\n        return schemaAtPos\n      } else if (has(sub, 'additionalItems')) {\n        return sub.additionalItems\n      }\n    } else {\n      return sub.items\n    }\n\n    return undefined\n  })\n}\n\nfunction getAdditionalSchemas(subSchemas) {\n  return subSchemas.map(function(sub) {\n    if (!sub) {\n      return undefined\n    }\n    if (Array.isArray(sub.items)) {\n      return sub.additionalItems\n    }\n    return sub.items\n  })\n}\n\n// Provide source when array\nfunction mergeItems(group, mergeSchemas, items) {\n  const allKeys = allUniqueKeys(items)\n  return allKeys.reduce(function(all, key) {\n    const schemas = getItemSchemas(group, key)\n    const compacted = uniqWith(schemas.filter(notUndefined), compare)\n    all[key] = mergeSchemas(compacted, key)\n    return all\n  }, [])\n}\n\nmodule.exports = {\n  keywords: ['items', 'additionalItems'],\n  resolver(values, parents, mergers) {\n    // const createSubMerger = groupKey => (schemas, key) => mergeSchemas(schemas, parents.concat(groupKey, key))\n    const items = values.map(s => s.items)\n    const itemsCompacted = items.filter(notUndefined)\n    const returnObject = {}\n\n    // if all items keyword values are schemas, we can merge them as simple schemas\n    // if not we need to merge them as mixed\n    if (itemsCompacted.every(isSchema)) {\n      returnObject.items = mergers.items(items)\n    } else {\n      returnObject.items = mergeItems(values, mergers.items, items)\n    }\n\n    let schemasAtLastPos\n    if (itemsCompacted.every(Array.isArray)) {\n      schemasAtLastPos = values.map(s => s.additionalItems)\n    } else if (itemsCompacted.some(Array.isArray)) {\n      schemasAtLastPos = getAdditionalSchemas(values)\n    }\n\n    if (schemasAtLastPos) {\n      returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos)\n    }\n\n    if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {\n      removeFalseSchemasFromArray(returnObject.items)\n    }\n\n    return deleteUndefinedProps(returnObject)\n  }\n}\n","\nconst compare = require('json-schema-compare')\nconst forEach = require('lodash/forEach')\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  getValues,\n  keys,\n  notUndefined,\n  uniqWith,\n  withoutArr\n} = require('../common')\n\nfunction removeFalseSchemas(target) {\n  forEach(target, function(schema, prop) {\n    if (schema === false) {\n      delete target[prop]\n    }\n  })\n}\n\nfunction mergeSchemaGroup(group, mergeSchemas) {\n  const allKeys = allUniqueKeys(group)\n  return allKeys.reduce(function(all, key) {\n    const schemas = getValues(group, key)\n    const compacted = uniqWith(schemas.filter(notUndefined), compare)\n    all[key] = mergeSchemas(compacted, key)\n    return all\n  }, {})\n}\n\nmodule.exports = {\n  keywords: ['properties', 'patternProperties', 'additionalProperties'],\n  resolver(values, parents, mergers, options) {\n    // first get rid of all non permitted properties\n    if (!options.ignoreAdditionalProperties) {\n      values.forEach(function(subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema)\n        const ownKeys = keys(subSchema.properties)\n        const ownPatternKeys = keys(subSchema.patternProperties)\n        const ownPatterns = ownPatternKeys.map(k => new RegExp(k))\n        otherSubSchemas.forEach(function(other) {\n          const allOtherKeys = keys(other.properties)\n          const keysMatchingPattern = allOtherKeys.filter(k => ownPatterns.some(pk => pk.test(k)))\n          const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern)\n          additionalKeys.forEach(function(key) {\n            other.properties[key] = mergers.properties([\n              other.properties[key], subSchema.additionalProperties\n            ], key)\n          })\n        })\n      })\n\n      // remove disallowed patternProperties\n      values.forEach(function(subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema)\n        const ownPatternKeys = keys(subSchema.patternProperties)\n        if (subSchema.additionalProperties === false) {\n          otherSubSchemas.forEach(function(other) {\n            const allOtherPatterns = keys(other.patternProperties)\n            const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys)\n            additionalPatternKeys.forEach(key => delete other.patternProperties[key])\n          })\n        }\n      })\n    }\n\n    const returnObject = {\n      additionalProperties: mergers.additionalProperties(values.map(s => s.additionalProperties)),\n      patternProperties: mergeSchemaGroup(values.map(s => s.patternProperties), mergers.patternProperties),\n      properties: mergeSchemaGroup(values.map(s => s.properties), mergers.properties)\n    }\n\n    if (returnObject.additionalProperties === false) {\n      removeFalseSchemas(returnObject.properties)\n    }\n\n    return deleteUndefinedProps(returnObject)\n  }\n}\n","const cloneDeep = require('lodash/cloneDeep')\nconst compare = require('json-schema-compare')\nconst computeLcm = require('compute-lcm')\nconst defaultsDeep = require('lodash/defaultsDeep')\nconst flatten = require('lodash/flatten')\nconst flattenDeep = require('lodash/flattenDeep')\nconst intersection = require('lodash/intersection')\nconst intersectionWith = require('lodash/intersectionWith')\nconst isEqual = require('lodash/isEqual')\nconst isPlainObject = require('lodash/isPlainObject')\nconst pullAll = require('lodash/pullAll')\nconst sortBy = require('lodash/sortBy')\nconst uniq = require('lodash/uniq')\nconst uniqWith = require('lodash/uniqWith')\n\nconst propertiesResolver = require('./complex-resolvers/properties')\nconst itemsResolver = require('./complex-resolvers/items')\n\nconst contains = (arr, val) => arr.indexOf(val) !== -1\nconst isSchema = (val) => isPlainObject(val) || val === true || val === false\nconst isFalse = (val) => val === false\nconst isTrue = (val) => val === true\nconst schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted)\nconst stringArray = (values) => sortBy(uniq(flattenDeep(values)))\nconst notUndefined = (val) => val !== undefined\nconst allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)))\n\n// resolvers\nconst first = compacted => compacted[0]\nconst required = compacted => stringArray(compacted)\nconst maximumValue = compacted => Math.max.apply(Math, compacted)\nconst minimumValue = compacted => Math.min.apply(Math, compacted)\nconst uniqueItems = compacted => compacted.some(isTrue)\nconst examples = compacted => uniqWith(flatten(compacted), isEqual)\n\nfunction compareProp(key) {\n  return function(a, b) {\n    return compare({\n      [key]: a\n    }, { [key]: b })\n  }\n}\n\nfunction getAllOf(schema) {\n  let { allOf = [], ...copy } = schema\n  copy = isPlainObject(schema) ? copy : schema // if schema is boolean\n  return [copy, ...allOf.map(getAllOf)]\n}\n\nfunction getValues(schemas, key) {\n  return schemas.map(schema => schema && schema[key])\n}\n\nfunction tryMergeSchemaGroups(schemaGroups, mergeSchemas) {\n  return schemaGroups.map(function(schemas, index) {\n    try {\n      return mergeSchemas(schemas, index)\n    } catch (e) {\n      return undefined\n    }\n  }).filter(notUndefined)\n}\n\nfunction keys(obj) {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj)\n  } else {\n    return []\n  }\n}\n\nfunction getAnyOfCombinations(arrOfArrays, combinations) {\n  combinations = combinations || []\n  if (!arrOfArrays.length) {\n    return combinations\n  }\n\n  const values = arrOfArrays.slice(0).shift()\n  const rest = arrOfArrays.slice(1)\n  if (combinations.length) {\n    return getAnyOfCombinations(rest, flatten(combinations.map(combination => values.map(item => ([item].concat(combination))))))\n  }\n  return getAnyOfCombinations(rest, values.map(item => (item)))\n}\n\nfunction throwIncompatible(values, paths) {\n  let asJSON\n  try {\n    asJSON = values.map(function(val) {\n      return JSON.stringify(val, null, 2)\n    }).join('\\n')\n  } catch (variable) {\n    asJSON = values.join(', ')\n  }\n  throw new Error('Could not resolve values for path:\"' + paths.join('.') + '\". They are probably incompatible. Values: \\n' + asJSON)\n}\n\nfunction callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {\n  if (complexKeywords.length) {\n    const resolverConfig = options.complexResolvers[resolverName]\n    if (!resolverConfig || !resolverConfig.resolver) {\n      throw new Error('No resolver found for ' + resolverName)\n    }\n\n    // extract all keywords from all the schemas that have one or more\n    // then remove all undefined ones and not unique\n    const extractedKeywordsOnly = schemas.map(schema => complexKeywords.reduce((all, key) => {\n      if (schema[key] !== undefined) all[key] = schema[key]\n      return all\n    }, {}))\n    const unique = uniqWith(extractedKeywordsOnly, compare)\n\n    // create mergers that automatically add the path of the keyword for use in the complex resolver\n    const mergers = resolverConfig.keywords.reduce((all, key) => ({\n      ...all,\n      [key]: (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))\n    }), {})\n\n    const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options)\n\n    if (!isPlainObject(result)) {\n      throwIncompatible(unique, parents.concat(resolverName))\n    }\n\n    return result\n  }\n}\n\nfunction createRequiredMetaArray(arr) {\n  return { required: arr }\n}\n\nconst schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies']\nconst schemaArrays = ['anyOf', 'oneOf']\nconst schemaProps = [\n  'additionalProperties',\n  'additionalItems',\n  'contains',\n  'propertyNames',\n  'not',\n  'items'\n]\n\nconst defaultResolvers = {\n  type(compacted) {\n    if (compacted.some(Array.isArray)) {\n      const normalized = compacted.map(function(val) {\n        return Array.isArray(val)\n          ? val\n          : [val]\n      })\n      const common = intersection.apply(null, normalized)\n\n      if (common.length === 1) {\n        return common[0]\n      } else if (common.length > 1) {\n        return uniq(common)\n      }\n    }\n  },\n  dependencies(compacted, paths, mergeSchemas) {\n    const allChildren = allUniqueKeys(compacted)\n\n    return allChildren.reduce(function(all, childKey) {\n      const childSchemas = getValues(compacted, childKey)\n      let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual)\n\n      // to support dependencies\n      const innerArrays = innerCompacted.filter(Array.isArray)\n\n      if (innerArrays.length) {\n        if (innerArrays.length === innerCompacted.length) {\n          all[childKey] = stringArray(innerCompacted)\n        } else {\n          const innerSchemas = innerCompacted.filter(isSchema)\n          const arrayMetaScheams = innerArrays.map(createRequiredMetaArray)\n          all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey)\n        }\n        return all\n      }\n\n      innerCompacted = uniqWith(innerCompacted, compare)\n\n      all[childKey] = mergeSchemas(innerCompacted, childKey)\n      return all\n    }, {})\n  },\n  oneOf(compacted, paths, mergeSchemas) {\n    const combinations = getAnyOfCombinations(cloneDeep(compacted))\n    const result = tryMergeSchemaGroups(combinations, mergeSchemas)\n    const unique = uniqWith(result, compare)\n\n    if (unique.length) {\n      return unique\n    }\n  },\n  not(compacted) {\n    return { anyOf: compacted }\n  },\n  pattern(compacted) {\n    return compacted.map(r => '(?=' + r + ')').join('')\n  },\n  multipleOf(compacted) {\n    let integers = compacted.slice(0)\n    let factor = 1\n    while (integers.some(n => !Number.isInteger(n))) {\n      integers = integers.map(n => n * 10)\n      factor = factor * 10\n    }\n    return computeLcm(integers) / factor\n  },\n  enum(compacted) {\n    const enums = intersectionWith.apply(null, compacted.concat(isEqual))\n    if (enums.length) {\n      return sortBy(enums)\n    }\n  }\n}\n\ndefaultResolvers.$id = first\ndefaultResolvers.$ref = first\ndefaultResolvers.$schema = first\ndefaultResolvers.additionalItems = schemaResolver\ndefaultResolvers.additionalProperties = schemaResolver\ndefaultResolvers.anyOf = defaultResolvers.oneOf\ndefaultResolvers.contains = schemaResolver\ndefaultResolvers.default = first\ndefaultResolvers.definitions = defaultResolvers.dependencies\ndefaultResolvers.description = first\ndefaultResolvers.examples = examples\ndefaultResolvers.exclusiveMaximum = minimumValue\ndefaultResolvers.exclusiveMinimum = maximumValue\ndefaultResolvers.items = itemsResolver\ndefaultResolvers.maximum = minimumValue\ndefaultResolvers.maxItems = minimumValue\ndefaultResolvers.maxLength = minimumValue\ndefaultResolvers.maxProperties = minimumValue\ndefaultResolvers.minimum = maximumValue\ndefaultResolvers.minItems = maximumValue\ndefaultResolvers.minLength = maximumValue\ndefaultResolvers.minProperties = maximumValue\ndefaultResolvers.properties = propertiesResolver\ndefaultResolvers.propertyNames = schemaResolver\ndefaultResolvers.required = required\ndefaultResolvers.title = first\ndefaultResolvers.uniqueItems = uniqueItems\n\nconst defaultComplexResolvers = {\n  properties: propertiesResolver,\n  items: itemsResolver\n}\n\nfunction merger(rootSchema, options, totalSchemas) {\n  totalSchemas = totalSchemas || []\n  options = defaultsDeep(options, {\n    ignoreAdditionalProperties: false,\n    resolvers: defaultResolvers,\n    complexResolvers: defaultComplexResolvers,\n    deep: true\n  })\n\n  const complexResolvers = Object.entries(options.complexResolvers)\n\n  function mergeSchemas(schemas, base, parents) {\n    schemas = cloneDeep(schemas.filter(notUndefined))\n    parents = parents || []\n    const merged = isPlainObject(base)\n      ? base\n      : {}\n\n    // return undefined, an empty schema\n    if (!schemas.length) {\n      return\n    }\n\n    if (schemas.some(isFalse)) {\n      return false\n    }\n\n    if (schemas.every(isTrue)) {\n      return true\n    }\n\n    // there are no false and we don't need the true ones as they accept everything\n    schemas = schemas.filter(isPlainObject)\n\n    const allKeys = allUniqueKeys(schemas)\n    if (options.deep && contains(allKeys, 'allOf')) {\n      return merger({\n        allOf: schemas\n      }, options, totalSchemas)\n    }\n\n    const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) =>\n      allKeys.filter(k => resolverConf.keywords.includes(k)))\n\n    // remove all complex keys before simple resolvers\n    complexKeysArr.forEach(keys => pullAll(allKeys, keys))\n\n    // call all simple resolvers for relevant keywords\n    allKeys.forEach(function(key) {\n      const values = getValues(schemas, key)\n      const compacted = uniqWith(values.filter(notUndefined), compareProp(key))\n\n      // arrayprops like anyOf and oneOf must be merged first, as they contains schemas\n      // allOf is treated differently alltogether\n      if (compacted.length === 1 && contains(schemaArrays, key)) {\n        merged[key] = compacted[0].map(schema => mergeSchemas([schema], schema))\n        // prop groups must always be resolved\n      } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {\n        merged[key] = compacted[0]\n      } else {\n        const resolver = options.resolvers[key] || options.resolvers.defaultResolver\n        if (!resolver) throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.')\n\n        const merger = (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))\n        merged[key] = resolver(compacted, parents.concat(key), merger, options)\n\n        if (merged[key] === undefined) {\n          throwIncompatible(compacted, parents.concat(key))\n        } else if (merged[key] === undefined) {\n          delete merged[key]\n        }\n      }\n    })\n\n    return complexResolvers.reduce((all, [resolverKeyword, config], index) => ({\n      ...all,\n      ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)\n    }), merged)\n  }\n\n  const allSchemas = flattenDeep(getAllOf(rootSchema))\n  const merged = mergeSchemas(allSchemas)\n\n  return merged\n}\n\nmerger.options = {\n  resolvers: defaultResolvers\n}\n\nmodule.exports = merger\n","var hasExcape = /~/\nvar escapeMatcher = /~[01]/g\nfunction escapeReplacer (m) {\n  switch (m) {\n    case '~1': return '/'\n    case '~0': return '~'\n  }\n  throw new Error('Invalid tilde escape: ' + m)\n}\n\nfunction untilde (str) {\n  if (!hasExcape.test(str)) return str\n  return str.replace(escapeMatcher, escapeReplacer)\n}\n\nfunction setter (obj, pointer, value) {\n  var part\n  var hasNextPart\n\n  for (var p = 1, len = pointer.length; p < len;) {\n    if (pointer[p] === 'constructor' || pointer[p] === 'prototype' || pointer[p] === '__proto__') return obj\n\n    part = untilde(pointer[p++])\n    hasNextPart = len > p\n\n    if (typeof obj[part] === 'undefined') {\n      // support setting of /-\n      if (Array.isArray(obj) && part === '-') {\n        part = obj.length\n      }\n\n      // support nested objects/array when setting values\n      if (hasNextPart) {\n        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []\n        else obj[part] = {}\n      }\n    }\n\n    if (!hasNextPart) break\n    obj = obj[part]\n  }\n\n  var oldValue = obj[part]\n  if (value === undefined) delete obj[part]\n  else obj[part] = value\n  return oldValue\n}\n\nfunction compilePointer (pointer) {\n  if (typeof pointer === 'string') {\n    pointer = pointer.split('/')\n    if (pointer[0] === '') return pointer\n    throw new Error('Invalid JSON pointer.')\n  } else if (Array.isArray(pointer)) {\n    for (const part of pointer) {\n      if (typeof part !== 'string' && typeof part !== 'number') {\n        throw new Error('Invalid JSON pointer. Must be of type string or number.')\n      }\n    }\n    return pointer\n  }\n\n  throw new Error('Invalid JSON pointer.')\n}\n\nfunction get (obj, pointer) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  var len = pointer.length\n  if (len === 1) return obj\n\n  for (var p = 1; p < len;) {\n    obj = obj[untilde(pointer[p++])]\n    if (len === p) return obj\n    if (typeof obj !== 'object' || obj === null) return undefined\n  }\n}\n\nfunction set (obj, pointer, value) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')\n  return setter(obj, pointer, value)\n}\n\nfunction compile (pointer) {\n  var compiled = compilePointer(pointer)\n  return {\n    get: function (object) {\n      return get(object, compiled)\n    },\n    set: function (object, value) {\n      return set(object, compiled, value)\n    }\n  }\n}\n\nexports.get = get\nexports.set = set\nexports.compile = compile\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n","/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    arrayMap = require('./_arrayMap'),\n    baseUnary = require('./_baseUnary'),\n    cacheHas = require('./_cacheHas');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = arrayMap(values, baseUnary(iteratee));\n  }\n  if (comparator) {\n    includes = arrayIncludesWith;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = cacheHas;\n    isCommon = false;\n    values = new SetCache(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee == null ? value : iteratee(value);\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseDifference;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n","/**\n * This function is like `baseIndexOf` except that it accepts a comparator.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOfWith(array, value, fromIndex, comparator) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (comparator(array[index], value)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseIndexOfWith;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    arrayMap = require('./_arrayMap'),\n    baseUnary = require('./_baseUnary'),\n    cacheHas = require('./_cacheHas');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * The base implementation of methods like `_.intersection`, without support\n * for iteratee shorthands, that accepts an array of arrays to inspect.\n *\n * @private\n * @param {Array} arrays The arrays to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of shared values.\n */\nfunction baseIntersection(arrays, iteratee, comparator) {\n  var includes = comparator ? arrayIncludesWith : arrayIncludes,\n      length = arrays[0].length,\n      othLength = arrays.length,\n      othIndex = othLength,\n      caches = Array(othLength),\n      maxLength = Infinity,\n      result = [];\n\n  while (othIndex--) {\n    var array = arrays[othIndex];\n    if (othIndex && iteratee) {\n      array = arrayMap(array, baseUnary(iteratee));\n    }\n    maxLength = nativeMin(array.length, maxLength);\n    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n      ? new SetCache(othIndex && array)\n      : undefined;\n  }\n  array = arrays[0];\n\n  var index = -1,\n      seen = caches[0];\n\n  outer:\n  while (++index < length && result.length < maxLength) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (!(seen\n          ? cacheHas(seen, computed)\n          : includes(result, computed, comparator)\n        )) {\n      othIndex = othLength;\n      while (--othIndex) {\n        var cache = caches[othIndex];\n        if (!(cache\n              ? cacheHas(cache, computed)\n              : includes(arrays[othIndex], computed, comparator))\n            ) {\n          continue outer;\n        }\n      }\n      if (seen) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseIntersection;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","var Stack = require('./_Stack'),\n    assignMergeValue = require('./_assignMergeValue'),\n    baseFor = require('./_baseFor'),\n    baseMergeDeep = require('./_baseMergeDeep'),\n    isObject = require('./isObject'),\n    keysIn = require('./keysIn'),\n    safeGet = require('./_safeGet');\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n","var assignMergeValue = require('./_assignMergeValue'),\n    cloneBuffer = require('./_cloneBuffer'),\n    cloneTypedArray = require('./_cloneTypedArray'),\n    copyArray = require('./_copyArray'),\n    initCloneObject = require('./_initCloneObject'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLikeObject = require('./isArrayLikeObject'),\n    isBuffer = require('./isBuffer'),\n    isFunction = require('./isFunction'),\n    isObject = require('./isObject'),\n    isPlainObject = require('./isPlainObject'),\n    isTypedArray = require('./isTypedArray'),\n    safeGet = require('./_safeGet'),\n    toPlainObject = require('./toPlainObject');\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n","var arrayMap = require('./_arrayMap'),\n    baseGet = require('./_baseGet'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    baseSortBy = require('./_baseSortBy'),\n    baseUnary = require('./_baseUnary'),\n    compareMultiple = require('./_compareMultiple'),\n    identity = require('./identity'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  if (iteratees.length) {\n    iteratees = arrayMap(iteratees, function(iteratee) {\n      if (isArray(iteratee)) {\n        return function(value) {\n          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n        }\n      }\n      return iteratee;\n    });\n  } else {\n    iteratees = [identity];\n  }\n\n  var index = -1;\n  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nmodule.exports = baseOrderBy;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","var arrayMap = require('./_arrayMap'),\n    baseIndexOf = require('./_baseIndexOf'),\n    baseIndexOfWith = require('./_baseIndexOfWith'),\n    baseUnary = require('./_baseUnary'),\n    copyArray = require('./_copyArray');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * The base implementation of `_.pullAllBy` without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to remove.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns `array`.\n */\nfunction basePullAll(array, values, iteratee, comparator) {\n  var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n      index = -1,\n      length = values.length,\n      seen = array;\n\n  if (array === values) {\n    values = copyArray(values);\n  }\n  if (iteratee) {\n    seen = arrayMap(array, baseUnary(iteratee));\n  }\n  while (++index < length) {\n    var fromIndex = 0,\n        value = values[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n      if (seen !== array) {\n        splice.call(seen, fromIndex, 1);\n      }\n      splice.call(array, fromIndex, 1);\n    }\n  }\n  return array;\n}\n\nmodule.exports = basePullAll;\n","/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var isArrayLikeObject = require('./isArrayLikeObject');\n\n/**\n * Casts `value` to an empty array if it's not an array like object.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array|Object} Returns the cast array-like object.\n */\nfunction castArrayLikeObject(value) {\n  return isArrayLikeObject(value) ? value : [];\n}\n\nmodule.exports = castArrayLikeObject;\n","var isSymbol = require('./isSymbol');\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = compareAscending;\n","var compareAscending = require('./_compareAscending');\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nmodule.exports = compareMultiple;\n","var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n","var baseMerge = require('./_baseMerge'),\n    isObject = require('./isObject');\n\n/**\n * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n * objects into destination objects that are passed thru.\n *\n * @private\n * @param {*} objValue The destination value.\n * @param {*} srcValue The source value.\n * @param {string} key The key of the property to merge.\n * @param {Object} object The parent object of `objValue`.\n * @param {Object} source The parent object of `srcValue`.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n * @returns {*} Returns the value to assign.\n */\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n  if (isObject(objValue) && isObject(srcValue)) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, objValue);\n    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n    stack['delete'](srcValue);\n  }\n  return objValue;\n}\n\nmodule.exports = customDefaultsMerge;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Check that cyclic values are equal.\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Check that cyclic values are equal.\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var baseRest = require('./_baseRest'),\n    eq = require('./eq'),\n    isIterateeCall = require('./_isIterateeCall'),\n    keysIn = require('./keysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nmodule.exports = defaults;\n","var apply = require('./_apply'),\n    baseRest = require('./_baseRest'),\n    customDefaultsMerge = require('./_customDefaultsMerge'),\n    mergeWith = require('./mergeWith');\n\n/**\n * This method is like `_.defaults` except that it recursively assigns\n * default properties.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaults\n * @example\n *\n * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n * // => { 'a': { 'b': 2, 'c': 3 } }\n */\nvar defaultsDeep = baseRest(function(args) {\n  args.push(undefined, customDefaultsMerge);\n  return apply(mergeWith, undefined, args);\n});\n\nmodule.exports = defaultsDeep;\n","var baseFlatten = require('./_baseFlatten');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Recursively flattens `array`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flattenDeep([1, [2, [3, [4]], 5]]);\n * // => [1, 2, 3, 4, 5]\n */\nfunction flattenDeep(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, INFINITY) : [];\n}\n\nmodule.exports = flattenDeep;\n","var arrayMap = require('./_arrayMap'),\n    baseIntersection = require('./_baseIntersection'),\n    baseRest = require('./_baseRest'),\n    castArrayLikeObject = require('./_castArrayLikeObject');\n\n/**\n * Creates an array of unique values that are included in all given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * _.intersection([2, 1], [2, 3]);\n * // => [2]\n */\nvar intersection = baseRest(function(arrays) {\n  var mapped = arrayMap(arrays, castArrayLikeObject);\n  return (mapped.length && mapped[0] === arrays[0])\n    ? baseIntersection(mapped)\n    : [];\n});\n\nmodule.exports = intersection;\n","var arrayMap = require('./_arrayMap'),\n    baseIntersection = require('./_baseIntersection'),\n    baseRest = require('./_baseRest'),\n    castArrayLikeObject = require('./_castArrayLikeObject'),\n    last = require('./last');\n\n/**\n * This method is like `_.intersection` except that it accepts `comparator`\n * which is invoked to compare elements of `arrays`. The order and references\n * of result values are determined by the first array. The comparator is\n * invoked with two arguments: (arrVal, othVal).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n *\n * _.intersectionWith(objects, others, _.isEqual);\n * // => [{ 'x': 1, 'y': 2 }]\n */\nvar intersectionWith = baseRest(function(arrays) {\n  var comparator = last(arrays),\n      mapped = arrayMap(arrays, castArrayLikeObject);\n\n  comparator = typeof comparator == 'function' ? comparator : undefined;\n  if (comparator) {\n    mapped.pop();\n  }\n  return (mapped.length && mapped[0] === arrays[0])\n    ? baseIntersection(mapped, undefined, comparator)\n    : [];\n});\n\nmodule.exports = intersectionWith;\n","var isArrayLike = require('./isArrayLike'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]';\n\n/**\n * Checks if `value` is classified as a boolean primitive or object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n * @example\n *\n * _.isBoolean(false);\n * // => true\n *\n * _.isBoolean(null);\n * // => false\n */\nfunction isBoolean(value) {\n  return value === true || value === false ||\n    (isObjectLike(value) && baseGetTag(value) == boolTag);\n}\n\nmodule.exports = isBoolean;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * This method is like `_.isEqual` except that it accepts `customizer` which\n * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n * are handled by the method instead. The `customizer` is invoked with up to\n * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * function isGreeting(value) {\n *   return /^h(?:i|ello)$/.test(value);\n * }\n *\n * function customizer(objValue, othValue) {\n *   if (isGreeting(objValue) && isGreeting(othValue)) {\n *     return true;\n *   }\n * }\n *\n * var array = ['hello', 'goodbye'];\n * var other = ['hi', 'goodbye'];\n *\n * _.isEqualWith(array, other, customizer);\n * // => true\n */\nfunction isEqualWith(value, other, customizer) {\n  customizer = typeof customizer == 'function' ? customizer : undefined;\n  var result = customizer ? customizer(value, other) : undefined;\n  return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n}\n\nmodule.exports = isEqualWith;\n","/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nmodule.exports = isNil;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n * classified as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && baseGetTag(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n","var baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n","var baseMerge = require('./_baseMerge'),\n    createAssigner = require('./_createAssigner');\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nmodule.exports = merge;\n","var baseMerge = require('./_baseMerge'),\n    createAssigner = require('./_createAssigner');\n\n/**\n * This method is like `_.merge` except that it accepts `customizer` which\n * is invoked to produce the merged values of the destination and source\n * properties. If `customizer` returns `undefined`, merging is handled by the\n * method instead. The `customizer` is invoked with six arguments:\n * (objValue, srcValue, key, object, source, stack).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   if (_.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * }\n *\n * var object = { 'a': [1], 'b': [2] };\n * var other = { 'a': [3], 'b': [4] };\n *\n * _.mergeWith(object, other, customizer);\n * // => { 'a': [1, 3], 'b': [2, 4] }\n */\nvar mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n  baseMerge(object, source, srcIndex, customizer);\n});\n\nmodule.exports = mergeWith;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","var basePullAll = require('./_basePullAll');\n\n/**\n * This method is like `_.pull` except that it accepts an array of values to remove.\n *\n * **Note:** Unlike `_.difference`, this method mutates `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to modify.\n * @param {Array} values The values to remove.\n * @returns {Array} Returns `array`.\n * @example\n *\n * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n *\n * _.pullAll(array, ['a', 'c']);\n * console.log(array);\n * // => ['b', 'b']\n */\nfunction pullAll(array, values) {\n  return (array && array.length && values && values.length)\n    ? basePullAll(array, values)\n    : array;\n}\n\nmodule.exports = pullAll;\n","var arrayReduce = require('./_arrayReduce'),\n    baseEach = require('./_baseEach'),\n    baseIteratee = require('./_baseIteratee'),\n    baseReduce = require('./_baseReduce'),\n    isArray = require('./isArray');\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nmodule.exports = reduce;\n","var baseFlatten = require('./_baseFlatten'),\n    baseOrderBy = require('./_baseOrderBy'),\n    baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 30 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nmodule.exports = sortBy;\n","var baseTimes = require('./_baseTimes'),\n    castFunction = require('./_castFunction'),\n    toInteger = require('./toInteger');\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Invokes the iteratee `n` times, returning an array of the results of\n * each invocation. The iteratee is invoked with one argument; (index).\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n * @example\n *\n * _.times(3, String);\n * // => ['0', '1', '2']\n *\n *  _.times(4, _.constant(0));\n * // => [0, 0, 0, 0]\n */\nfunction times(n, iteratee) {\n  n = toInteger(n);\n  if (n < 1 || n > MAX_SAFE_INTEGER) {\n    return [];\n  }\n  var index = MAX_ARRAY_LENGTH,\n      length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n  iteratee = castFunction(iteratee);\n  n -= MAX_ARRAY_LENGTH;\n\n  var result = baseTimes(length, iteratee);\n  while (++index < n) {\n    iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = times;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n","var arrayEach = require('./_arrayEach'),\n    baseCreate = require('./_baseCreate'),\n    baseForOwn = require('./_baseForOwn'),\n    baseIteratee = require('./_baseIteratee'),\n    getPrototype = require('./_getPrototype'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isFunction = require('./isFunction'),\n    isObject = require('./isObject'),\n    isTypedArray = require('./isTypedArray');\n\n/**\n * An alternative to `_.reduce`; this method transforms `object` to a new\n * `accumulator` object which is the result of running each of its own\n * enumerable string keyed properties thru `iteratee`, with each invocation\n * potentially mutating the `accumulator` object. If `accumulator` is not\n * provided, a new object with the same `[[Prototype]]` will be used. The\n * iteratee is invoked with four arguments: (accumulator, value, key, object).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @since 1.3.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The custom accumulator value.\n * @returns {*} Returns the accumulated value.\n * @example\n *\n * _.transform([2, 3, 4], function(result, n) {\n *   result.push(n *= n);\n *   return n % 2 == 0;\n * }, []);\n * // => [4, 9]\n *\n * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] }\n */\nfunction transform(object, iteratee, accumulator) {\n  var isArr = isArray(object),\n      isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n  iteratee = baseIteratee(iteratee, 4);\n  if (accumulator == null) {\n    var Ctor = object && object.constructor;\n    if (isArrLike) {\n      accumulator = isArr ? new Ctor : [];\n    }\n    else if (isObject(object)) {\n      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n    }\n    else {\n      accumulator = {};\n    }\n  }\n  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n    return iteratee(accumulator, value, index, object);\n  });\n  return accumulator;\n}\n\nmodule.exports = transform;\n","var baseFlatten = require('./_baseFlatten'),\n    baseRest = require('./_baseRest'),\n    baseUniq = require('./_baseUniq'),\n    isArrayLikeObject = require('./isArrayLikeObject');\n\n/**\n * Creates an array of unique values, in order, from all given arrays using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * _.union([2], [1, 2]);\n * // => [2, 1]\n */\nvar union = baseRest(function(arrays) {\n  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n});\n\nmodule.exports = union;\n","var baseUniq = require('./_baseUniq');\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nmodule.exports = uniq;\n","var baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `comparator` which\n * is invoked to compare elements of `array`. The order of result values is\n * determined by the order they occur in the array.The comparator is invoked\n * with two arguments: (arrVal, othVal).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n *\n * _.uniqWith(objects, _.isEqual);\n * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n */\nfunction uniqWith(array, comparator) {\n  comparator = typeof comparator == 'function' ? comparator : undefined;\n  return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n}\n\nmodule.exports = uniqWith;\n","var baseDifference = require('./_baseDifference'),\n    baseRest = require('./_baseRest'),\n    isArrayLikeObject = require('./isArrayLikeObject');\n\n/**\n * Creates an array excluding all given values using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * **Note:** Unlike `_.pull`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...*} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.difference, _.xor\n * @example\n *\n * _.without([2, 1, 2, 3], 1, 2);\n * // => [3]\n */\nvar without = baseRest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, values)\n    : [];\n});\n\nmodule.exports = without;\n","'use strict';\n\n/**\n* FUNCTION: isArray( value )\n*\tValidates if a value is an array.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is an array\n*/\nfunction isArray( value ) {\n\treturn Object.prototype.toString.call( value ) === '[object Array]';\n} // end FUNCTION isArray()\n\n// EXPORTS //\n\nmodule.exports = Array.isArray || isArray;\n","/**\n*\n*\tVALIDATE: function\n*\n*\n*\tDESCRIPTION:\n*\t\t- Validates if a value is a function.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n'use strict';\n\n/**\n* FUNCTION: isFunction( value )\n*\tValidates if a value is a function.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is a function\n*/\nfunction isFunction( value ) {\n\treturn ( typeof value === 'function' );\n} // end FUNCTION isFunction()\n\n\n// EXPORTS //\n\nmodule.exports = isFunction;\n","/**\n*\n*\tVALIDATE: integer-array\n*\n*\n*\tDESCRIPTION:\n*\t\t- Validates if a value is an integer array.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2015. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2015.\n*\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isArray = require( 'validate.io-array' ),\n\tisInteger = require( 'validate.io-integer' );\n\n\n// IS INTEGER ARRAY //\n\n/**\n* FUNCTION: isIntegerArray( value )\n*\tValidates if a value is an integer array.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating if a value is an integer array\n*/\nfunction isIntegerArray( value ) {\n\tvar len;\n\tif ( !isArray( value ) ) {\n\t\treturn false;\n\t}\n\tlen = value.length;\n\tif ( !len ) {\n\t\treturn false;\n\t}\n\tfor ( var i = 0; i < len; i++ ) {\n\t\tif ( !isInteger( value[i] ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n} // end FUNCTION isIntegerArray()\n\n\n// EXPORTS //\n\nmodule.exports = isIntegerArray;\n","/**\n*\n*\tVALIDATE: integer\n*\n*\n*\tDESCRIPTION:\n*\t\t- Validates if a value is an integer.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isNumber = require( 'validate.io-number' );\n\n\n// ISINTEGER //\n\n/**\n* FUNCTION: isInteger( value )\n*\tValidates if a value is an integer.\n*\n* @param {Number} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is an integer\n*/\nfunction isInteger( value ) {\n\treturn isNumber( value ) && value%1 === 0;\n} // end FUNCTION isInteger()\n\n\n// EXPORTS //\n\nmodule.exports = isInteger;\n","/**\n*\n*\tVALIDATE: number\n*\n*\n*\tDESCRIPTION:\n*\t\t- Validates if a value is a number.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n'use strict';\n\n/**\n* FUNCTION: isNumber( value )\n*\tValidates if a value is a number.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is a number\n*/\nfunction isNumber( value ) {\n\treturn ( typeof value === 'number' || Object.prototype.toString.call( value ) === '[object Number]' ) && value.valueOf() === value.valueOf();\n} // end FUNCTION isNumber()\n\n\n// EXPORTS //\n\nmodule.exports = isNumber;\n"],"names":[],"sourceRoot":""}